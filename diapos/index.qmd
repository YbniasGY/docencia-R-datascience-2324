---
title: "SOFTWARE II"
subtitle: "An√°lisis de datos en R para Ciencia de Datos"
title-slide-attributes:
  data-background-image: img/data-science-2.jpeg
  data-background-size: cover
  data-background-opacity: "0.2"
author: "Grado en Ciencia de Datos Aplicada ‚Ä¢ curso 2023-2024"
affiliation: Facultad de Estudios Estad√≠sticos (UCM)
lang: es
language: custom_lang.yml
format: 
  revealjs:
    theme: [default, style.scss]
    chalkboard: true
    multiplex: true
    menu:
      side: left
      width: normal
    footer: "[<strong>Javier √Ålvarez Li√©bana</strong>](...) ‚Ä¢ Grado en Ciencia de Datos Aplicada (UCM) ‚Ä¢ curso 2023-2024"
    slide-number: c/t
execute:
  echo: true
---

# ¬°Bienvenidos a R!

[**Dejad vuestras hojas de c√°lculo y Anacondas a un lado**]{style="color:#444442;"}

---

## ¬°Buenas!

[**Correo**]{.hl-green}: **<javalv09@ucm.es>**. [**Despacho**]{.hl-green}: 722 (3¬™ planta). [**Tutor√≠as**]{.hl-green}: lunes (14:30-16:00), martes (12:00-13:00) y viernes (13:00-14:00).

::: columns
::: {.column width="30%"}
![](img/me.jpeg)
:::

::: {.column width="70%"}
::: incremental
-   [**Javier √Ålvarez Li√©bana**]{.hl-yellow}, de Carabanchel (Bajo).

-   Licenciado en Matem√°ticas (UCM). [**Doctorado en estad√≠stica**]{.hl-yellow} (UGR).

-   Encargado de la [**visualizaci√≥n y an√°lisis de datos covid**]{.hl-yellow} del Principado de Asturias (2021-2022).

-   Miembro de la [**Sociedad Espa√±ola de Estad√≠stica e IO**]{.hl-yellow} y la [**Real Sociedad Matem√°tica Espa√±ola**]{.hl-yellow}.
:::
:::
:::

. . .

Actualmente, [**investigador y docente en la Facultad de Estad√≠stica de la UCM**]{.hl-yellow}. Divulgando por [**Twitter**](https://twitter.com/dadosdelaplace) e [**Instagram**](https://instagram.com/javieralvarezliebana)


---

## Objetivos

::: columns
::: {.column width="37%"}
![](https://assets-global.website-files.com/6092cb6b4ac959f39728dd26/6188a97fa499b5fbfe410417_target%20(1).png)
:::

::: {.column width="63%"}
::: incremental
-   Quitarnos el [**miedo a los errores en programaci√≥n**]{.hl-yellow} ‚Üí a programar se aprende programando

-   Entender los [**conceptos b√°sicos de R**]{.hl-yellow} desde cero ‚Üí aprender a abstraer ideas y algoritmos

-   Utilidad de programar ‚Üí flujos de trabajo [**reproducibles**, **transparentes**]{.hl-yellow} y mantenibles

-   Introducci√≥n al [**an√°lisis y preprocesamiento**]{.hl-yellow} de datos ‚Üí `{tidyverse}`

-   Adquirir habilidades en la [**visualizaci√≥n de datos**]{.hl-yellow} ‚Üí `{ggplot2}`
:::
:::
:::

---

## Evaluaci√≥n

-   [**Asistencia**]{.hl-yellow}. La asistencia no ser√° obligatoria pero si se [**valorar√° muy positivamente**]{.hl-purple} la participaci√≥n en clase (nunca penalizando).

. . .

-   [**Evaluaci√≥n**]{.hl-yellow}. A lo largo del curso se han planteado [**5 entregas individuales**]{.hl-purple}, as√≠ como una [**entrega final grupal**]{.hl-purple} (entre 2 y 4 personas) donde se deber√° presentar el an√°lisis realizado de un caso real.

. . .

-   [**Nota m√≠nima**]{.hl-yellow}. Para no ir al examen final se [**deber√° obtener al menos un 4/10**]{.hl-purple} en cada entrega o una [**media ponderada superior al 6/10**]{.hl-purple}. Se deber√° obtener adem√°s en la [**entrega grupal una nota superior a 6-6.5-7/10**]{.hl-purple} (seg√∫n 2-3-4 personas)

. . .

-   [**Examen final**]{.hl-yellow}. Cualquier alumno podr√° presentarse a un examen final, siendo la valoraci√≥n del mismo el 100% de su nota (perdiendo la evaluaci√≥n continua).

---

## Planificaci√≥n I

::: column-screen-inset-right
::: {style="font-size:20px"}
|  CLASE | SEMANA | FECHAS | TOPIC | SCRIPTS | EJ. | CASO PR√ÅCTICO | ENTREGA | 
|:------:|:--------:|:--------:|:------:|:------:|:------:|:------:|:------:|:------:|:------:|
|     [1](#clase-1-primeros-pasos)      | S1     | 12 sep |                  Primeros pasos en R                   | [üìù](https://github.com/dadosdelaplace/docencia-R-datascience-2324/tree/main/material/scripts)  |                 [üíª](#tu-turno)                 |                        |         | 
|     [2](#clase-2-primeros-datos)      | S1     | 15 sep |                 Tipos b√°sicos de datos y vectores                | [üìù](https://github.com/dadosdelaplace/docencia-R-datascience-2324/tree/main/material/scripts)  |       [üíª](#tu-turno-1) [üíª](#tu-turno-2)       |  [üê£](#caso-pr√°ctico)  |         |   
|     [3](#clase-3)      | S2     | 19 sep |                 Primeras bases de datos              | [üìù](https://github.com/dadosdelaplace/docencia-R-datascience-2324/tree/main/material/scripts)  |       [üíª](#tu-turno-3) [üíª](#tu-turno-matrices) [üíª](#tu-turno-tibble)   |  [üê£](#caso-pr√°ctico-1)  |         |   
|     [4](#clase-4)      | S2     | 19 sep |      Comunicar y elaborar informes/entregas              | [üìù](https://github.com/dadosdelaplace/docencia-R-datascience-2324/tree/main/material/scripts)  |       |  [üê£](#caso-pr√°ctico-3a)  |         | 
|   [5](#entrega-i)   | S3 | 26 sep | Entrega I |  |  [üíª](#entrega-i)   |  |  üéØ 5%  | 
|     [6](#clase-6)      | S3     | 29 sep |      Tidydata: intro a tidyverse             | [üìù](https://github.com/dadosdelaplace/docencia-R-datascience-2324/tree/main/material/scripts)  |     [üíª](#tu-turno-6)  |  [üê£](#caso-pr√°ctico-6)  |         |
|   [7](#clase-7-importar)   | S4     | 3 oct |       Importar y exportar archivos  | [üìù]()  |                [üíª](#tu-turno-7)             |        [üê£](#caso-pr√°ctico-7)          |         | 
|   [8](#entrega-ii)   | S4 | 6 oct | Entrega II |  |  [üíª](#entrega-ii)   |  |  üéØ 15%  | 
:::
:::

---

## Materiales

* [**Diapositivas**]{.hl-yellow}: las diapositivas que usaremos en el aula a lo largo del curso, estructuradas por clases, estar√°n disponibles y actualizadas en **<https://javieralvarezliebana.es/docencia-R-datascience-2324/diapos>** 

En el men√∫ de las diapositivas (abajo a la izquierda) tienes una [**opci√≥n para descargarlas en pdf**]{.hl-yellow} en `Tools` (consejo: no lo hagas hasta el final del curso ya que ir√°n modific√°ndose)
  
&nbsp;

* [**Material**]{.hl-yellow}: [**scripts de cada tema**](https://github.com/dadosdelaplace/docencia-R-datascience-2324/tree/main/material) y materiales extras

* [**Res√∫menes de paquetes**]{.hl-yellow}: [**chuletas de los paquetes**](https://github.com/dadosdelaplace/docencia-R-datascience-2324/tree/main/fichas%20paquetes) en formato .pdf


# Clase 1: primeros pasos {#clase-1-primeros-pasos}

[**Instalando R y RStudio. Primeros pasos. Scripts y proyectos**]{style="color:#444442;"}

---

## Requisitos

Para el curso los √∫nicos requisitos ser√°n:

1.  [**Conexi√≥n a internet**]{.hl-yellow} (para la descarga de algunos datos y paquetes).

2.  [**Instalar R**]{.hl-yellow}[: ser√° nuestro lenguaje. La descarga la haremos (gratuitamente) desde <https://cran.r-project.org/>]{.fragment .fade-in}

::: {.fragment .fade-in}
3.  [**Instalar RStudio**]{.hl-yellow} desde <https://posit.co/download/rstudio-desktop/>
:::

::: columns
::: {.column width="50%"}
![](img/cranR.jpg){width="420"}
:::

::: {.column width="50%"}
![](img/rstudio.jpg){width="420"}
:::
:::

---

::: columns
::: {.column width="50%"}
![](img/gramatica.webp){width="400"}
:::

::: {.column width="50%"}
![](img/word.jpg){width="470"}
:::
:::

::: {.fragment .fade-in-then-out}
Programaremos como escribimos (castellano, por ejemplo) ‚Üí `R` es [**lenguaje**]{.hl-yellow}
:::

::: {.fragment .fade-up}
-   Necesitaremos una [**gram√°tica**]{.hl-yellow} (`R`)

::: {.fragment .fade-in}
-   Y un entorno, por ejemplo un [**Word**]{.hl-yellow} (`RStudio`), para escribirlo
:::
:::

---

## Instalaci√≥n de R

El lenguaje `R` ser√° nuestra [**gram√°tica y ortograf√≠a**]{.hl-yellow} (nuestras reglas de juego)

::: incremental
-   [**Paso 1**]{.hl-yellow}: entra en <https://cran.r-project.org/> y selecciona tu sistema operativo.

-   [**Paso 2**]{.hl-yellow}: para Mac basta con que hacer click en el **archivo .pkg**, y abrirlo una vez descargado. Para sistemas Windows, debemos clickar en **install R for the first time** y despu√©s en **Download R for Windows**. Una vez descargado, abrirlo como cualquier archivo de instalaci√≥n.

-   [**Paso 3**]{.hl-yellow}: abrir el ejecutable de instalaci√≥n.
:::

. . .

::: callout-warning
Siempre que tengas que descargar algo de CRAN (ya sea el propio R o un paquete), [**aseg√∫rate de tener conexi√≥n a internet**]{.hl-orange}.
:::

---

## Primera operaci√≥n

::: columns
::: {.column width="65%"}
Para comprobar que se ha instalado correctamente, tras abrir `R`, deber√≠as ver una **pantalla blanca** similar a esta.

Esa ¬´pantalla blanca¬ª se llama [**consola**]{.hl-yellow} y podemos hacer un primer uso de ella como una **calculadora**.
:::

::: {.column width="35%"}
![](img/consola.jpg){width="200"}
:::
:::

. . .

[**Idea**]{.hl-yellow}: a una variable llamada `a` le asignaremos el valor `1` (escribiremos el c√≥digo de abajo en la consola y daremos ¬´enter¬ª)

```{r}
#| code-line-numbers: "1"
a <- 1
```

---

## Primera operaci√≥n

::: columns
::: {.column width="65%"}
Para comprobar que se ha instalado correctamente, tras abrir `R`, deber√≠as ver una **pantalla blanca** similar a esta.

Esa ¬´pantalla blanca¬ª se llama [**consola**]{.hl-yellow} y podemos hacer un primer uso de ella como una **calculadora**.
:::

::: {.column width="35%"}
![](img/consola.jpg){width="200"}
:::
:::

[**Idea**]{.hl-yellow}: definiremos otra variable llamada `b` y le asignaremos el valor `2`

```{r}
#| code-line-numbers: "2"
a <- 1
b <- 2
```

. . .

::: callout-note
## F√≠jate que...

En `R` usaremos `<-` como una flecha: la variable a la izquierda de dicha flecha le asignamos el valor que hay a la derecha (por ejemplo, `a <- 1`)
:::

---

## Primera operaci√≥n

::: columns
::: {.column width="65%"}
Para comprobar que se ha instalado correctamente, tras abrir `R`, deber√≠as ver una **pantalla blanca** similar a esta.

Esa ¬´pantalla blanca¬ª se llama [**consola**]{.hl-yellow} y podemos hacer un primer uso de ella como una **calculadora**.
:::

::: {.column width="35%"}
![](img/consola.jpg){width="270"}
:::
:::

[**Idea**]{.hl-yellow}: haremos la suma `a + b` y nos devolver√° su resultado

```{r}
#| code-line-numbers: "3"
a <- 1
b <- 2
a + b
```

---

## Instalaci√≥n de R Studio

`RStudio` ser√° el [**Word**]{.hl-yellow} que usaremos para escribir (lo que se conoce como un [**IDE: entorno integrado de desarrollo**]{.hl-yellow}).

::: incremental
-   [**Paso 1**]{.hl-yellow}: entra la [web oficial de RStudio](https://posit.co/download/rstudio-desktop/) (ahora llamado Posit) y selecciona la descarga gratuita.

-   [**Paso 2**]{.hl-yellow}: selecciona el ejecutable que te aparezca acorde a tu sistema operativo.

-   [**Paso 3**]{.hl-yellow}: tras descargar el ejecutable, hay que abrirlo como otro cualquier otro y dejar que termine la instalaci√≥n.
:::

---

## Organizaci√≥n de RStudio

Al abrir `RStudio` seguramente tengas tres ventanas:

-   [**Consola**]{.hl-yellow}: es el nombre para llamar a la ventana grande que te ocupa buena parte de tu pantalla. Prueba a escribir el mismo c√≥digo que antes (la suma de las variables) en ella. La consola ser√° donde **ejecutaremos √≥rdenes y mostraremos resultados**.

![](img/consola_rstudio.jpg){width="420"}

---

## Organizaci√≥n de RStudio

Al abrir `RStudio` seguramente tengas tres ventanas:

-   [**Environment**]{.hl-yellow}: la pantalla peque√±a (puedes ajustar los m√°rgenes con el rat√≥n a tu gusto) que tenemos en la parte superior derecha. Nos mostrar√° las **variables que tenemos definidas**.

![](img/environment.jpg){width="420"}

---

## Organizaci√≥n de RStudio

Al abrir `RStudio` seguramente tengas tres ventanas:

-   [**Panel multiusos**]{.hl-yellow}: la ventana que tenemos en la parte inferior derecha no servir√° para buscar **ayuda de funciones**, adem√°s de para **visualizar gr√°ficos**.

![](img/multiusos.jpg){width="420"}

---

## ¬øQu√© es R? ¬øPor qu√© R?

![](img/meme_barco.jpg)

---

## ¬øQu√© es R? ¬øPor qu√© R?

`R` es el [**lenguaje estad√≠stico por excelencia**]{.hl-yellow}, creado por y para estad√≠sticos/as, con 5 ventajas fundamentales [**frente a Excel**]{.hl-red}:

::: incremental
-   [**Lenguaje de programaci√≥n**]{.hl-yellow}: la obviedad [‚Üí an√°lisis]{.fragment .fade-in}[**replicables**]{.hl-purple}

-   [**Gratuito**]{.hl-yellow}: la filosof√≠a de la comunidad de `R` es el compartir c√≥digo bajo **copyleft** [‚Üí]{.fragment .fade-in}[**uso √©tico de dinero p√∫blico**]{.hl-purple}

-   [**Software libre**]{.hl-yellow}: no solo es gratis sino que permite acceder libremente a c√≥digo ajeno, incluso al **propio c√≥digo fuente** [‚Üí]{.fragment .fade-in}[**flexibilidad y transparencia**]{.hl-purple}

-   [**Lenguaje modular**]{.hl-yellow}: hemos instalado lo m√≠nimo, pero existen c√≥digos de otras personas que podemos reusar (casi 20 000 [**paquetes**]{.hl-yellow}) [‚Üí]{.fragment .fade-in}[**ahorro de tiempo**]{.hl-purple}

-   [**Lenguaje de alto nivel**]{.hl-yellow}: facilita la programaci√≥n (como Python) [‚Üí]{.fragment .fade-in}[**menor curva de aprendizaje**]{.hl-purple}
:::

---

## ¬øQu√© es R? ¬øPor qu√© R?

![](img/incel_excel.png)

---

## ¬øPor qu√© programar?

-   [**Automatizar**]{.hl-yellow} ‚Üí te permitir√° automatizar tareas recurrentes.

-   [**Replicabilidad**]{.hl-yellow} ‚Üí podr√°s replicar tu an√°lisis siempre de la misma manera.

-   [**Flexibilidad**]{.hl-yellow} ‚Üí podr√°s adaptar el software a tus necesidades.

-   [**Transparencia**]{.hl-yellow} ‚Üí ser auditado por la comunidad.

![](img/the_general_problem.png)

---

## Idea fundamental: paquetes

Una de las ideas claves de `R` es el [**uso de paquetes**]{.hl-yellow}: c√≥digos que otras personas han implementado para **resolver un problema**

::: columns
::: {.column width="35%"}
![](img/paquetes.png)
:::

::: {.column width="65%"}
::: {.fragment fragment-index="1"}
-   [**Instalaci√≥n**]{.hl-yellow}: descargamos los c√≥digos de la web (necesitamos internet) ‚Üí [**comprar un libro**]{.hl-purple}, solo una vez (por ordenador)

```{r}
#| eval: false
install.packages("ggplot2")
```
:::

::: {.fragment fragment-index="2"}
-   [**Carga**]{.hl-yellow}: con el paquete descargado, indicamos qu√© paquetes queremos usar cada vez que abramos `RStudio` ‚Üí [**traer el libro de la estanter√≠a**]{.hl-purple}

```{r}
#| eval: false
library(ggplot2)
```
:::
:::
:::

---

## Idea fundamental: paquetes

::: columns
::: {.column width="35%"}
![](img/paquetes.png)
:::

::: {.column width="65%"}
Una vez instalado, hay dos manera de usar un paquete (traerlo de la estanter√≠a)

::: {.fragment fragment-index="1"}
-   [**Paquete entero**]{.hl-yellow}: con `library()`, usando el nombre del paquete sin comillas, cargamos en la sesi√≥n [**todo el libro**]{.hl-purple}

```{r}
#| eval: false
library(ggplot2)
```
:::

::: {.fragment fragment-index="2"}
-   [**Funciones concretas**]{.hl-yellow} usando `paquete::funcion` le √≠ndicamos que solo queremos una [**p√°gina concreta de ese libro**]{.hl-purple}

```{r}
#| eval: false
ggplot2::geom_point()
```
:::
:::
:::

---

## Te vas equivocar

Durante tu aprendizaje va a ser muy habitual que las cosas no salgan a la primera ‚Üí [**te vas equivocar**]{.hl-yellow}. No solo ser√° importante asumirlo sino que es [**importante leer los mensajes de error**]{.hl-yellow} para aprender de ellos.

. . .

-   [**Mensajes de error**]{.hl-red}: precedidos de **¬´Error in...¬ª** y ser√°n aquellos fallos que [**impidan la ejecuci√≥n**]{.hl-red}

```{r}
#| error: true
"a" + 1 
```

. . .

-   [**Mensajes de warning**]{.hl-orange}: precedidos de **¬´Warning in...¬ª** son los (posibles) fallos m√°s delicados ya que son incoherencias que [**no impiden la ejecuci√≥n**]{.hl-orange}

```{r}
#| warning: true
# Ejecuta la orden pero el resultado es NaN, **Not A Number**, un valor que no existe
sqrt(-1)
```

---

## Scripts (documentos .R)

::: columns
::: {.column width="35%"}
![](img/abrir_script.jpg){width="350"}
:::

::: {.column width="65%"}
Un [**script**]{.hl-yellow} ser√° el documento en el que programamos, nuestro archivo `.doc` (aqu√≠ con extensi√≥n `.R`) donde escribiremos las √≥rdenes. Para **abrir nuestro primero script**, haz click en el men√∫ en `File < New File < R Script`.
:::
:::

::: callout-warning
## Cuidado

Es importante **no abusar de la consola**: todo lo que no escribas en un script, cuando cierres, [**lo habr√°s perdido**]{.hl-orange}.
:::

---

## Ejecutando el primer script

Ahora tenemos una **cuarta ventana**: la ventana donde [**escribiremos nuestros c√≥digos**]{.hl-yellow}. ¬øC√≥mo ejecutarlo?

. . .

1.  **Escribimos** el c√≥digo a ejecutar.

. . .

2.  **Guardamos** el archivo .R haciendo click en `Save current document`.

. . .

3.  El c√≥digo no se ejecuta salvo que se lo indiquemos. Tenemos tres opciones:

-   [**Copiar y pegar**]{.hl-yellow} en consola.
-   [**Seleccionar l√≠neas**]{.hl-yellow} y `Ctrl+Enter`
-   [**Activar Source on save**]{.hl-yellow} a la derecha de guardar: no solo guarda sino que ejecuta el c√≥digo **completo**.

---

## üíª Tu turno {#tu-turno}

[**Ejecuta tu primer script**: crea un script de cero, programa lo indicado debajo y ejec√∫talo (de las 3 maneras posibles)]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

üìù Define una variable de nombre `a` y cuyo valor sea -1

```{r}
#| code-fold: true
a <- -1
```

### [**Ejercicio 2**]{.hl-yellow}

üìù A√±ade debajo otra l√≠nea para definir una variable `b` con el valor 5. Tras ello m√∫ltiplica ambas variables

```{r}
#| code-fold: true
#| eval: false
b <- 5
a * b # sin guardar
multiplicacion <- a * b # guardado
```

### [**Ejercicio 3**]{.hl-yellow}

üìù Modifica el c√≥digo inferior para definir dos variables c y d, con valores 3 y -1. Tras ello divide las variables.

```{r}
#| eval: false
c <- # deber√≠as asignarle el valor 3
d <- # deber√≠as asignarle el valor -1
```

```{r}
#| code-fold: true
#| eval: false
c <- 3
d <- -1
c / d # sin guardar
division <- c / d # guardado
```

### [**Ejercicio 4**]{.hl-yellow}

üìù Asigna un valor positivo a `x` y calcula su ra√≠z cuadrada; asigna otro negativo `y` y calcula su valor absoluto con la funci√≥n `abs()`.

```{r}
#| code-fold: true
#| eval: false
x <- 5
sqrt(x)

y <- -2
abs(y)
```

### [**Ejercicio 5**]{.hl-yellow}

üìù Usando la variable `x` ya definida, completa/modifica el c√≥digo inferior para guardar en una nueva variable `z` el resultado guardado en `x` menos 5.

```{r}
#| eval: false
z <- ? - ? # completa el c√≥digo
z
```

```{r}
#| code-fold: true
#| eval: false
z <- x - 5
z
```
:::

::: callout-note
## Toma nota

Comandos como `sqrt()`, `abs()` o `max()` son lo que llamamos [**funciones**]{.hl-purple}: l√≠neas de c√≥digo que hemos ¬´encapsulado¬ª bajo un nombre, y dado unos argumentos de entrada, ejecuta las √≥rdenes (una especie de atajo).
:::

---

## S√© organizado: proyectos

De la misma manera que en el ordenador solemos trabajar de manera [**ordenada por carpetas**]{.hl-yellow}, en `RStudio` podemos hacer lo mismo para trabajar de [**manera eficaz creando proyectos**]{.hl-yellow}.

. . .

::: columns
::: {.column width="60%"}
Un [**proyecto ser√° una ¬´carpeta¬ª**]{.hl-yellow} dentro de `RStudio`, de manera que nuestro directorio ra√≠z autom√°ticamente ser√° la propia carpeta de proyecto (pudiendo pasar de un proyecto a otro con el menu superior derecho).

Podemos crear uno en una carpeta nueva o en una carpeta ya existente.
:::

::: {.column width="40%"}
![](img/rstudio_proyectos.png){width="370"}
:::
:::

---

## Filosof√≠a: de la CELDA a la TABLA

¬øQu√© [**tipo de dato**]{.hl-yellow} podemos tener en cada celda de una **tabla**?

![](img/celdas.jpg){fig-align="middle"}

::: incremental
-   [**Celda**]{.hl-yellow}: dato individual de un tipo concreto.
-   [**Variable**]{.hl-yellow}: **concatenaci√≥n** de valores del mismo tipo ([**vectores**]{.hl-purple}).
-   [**Matriz**]{.hl-yellow}: concatenaci√≥n de variables del **mismo tipo y longitud**.
-   [**Tabla**]{.hl-yellow}: concatenaci√≥n de variables de [**distinto tipo pero igual longitud**]{.hl-purple}
-   [**Lista**]{.hl-yellow}: concatenaci√≥n de variables de [**distinto tipo y distinta longitud**]{.hl-purple}
:::

# Clase 2: primeros datos y vectores {#clase-2-primeros-datos}

[**¬øQu√© tipos de celdas (datos) existen? Concatenando celdas: vectores**]{style="color:#444442;"}

---

## De la CELDA a la TABLA

¬øQu√© [**tipo de dato**]{.hl-yellow} podemos tener en cada celda de una **tabla**?

![](img/celdas.jpg){fig-align="middle"}

::: incremental
-   [**Celda**]{.hl-yellow}: dato individual de un tipo concreto.
-   [**Variable**]{.hl-yellow}: **concatenaci√≥n** de valores del mismo tipo ([**vectores**]{.hl-purple}).
-   [**Matriz**]{.hl-yellow}: concatenaci√≥n de variables del **mismo tipo y longitud**.
-   [**Tabla**]{.hl-yellow}: concatenaci√≥n de variables de [**distinto tipo pero igual longitud**]{.hl-purple}
-   [**Lista**]{.hl-yellow}: concatenaci√≥n de variables de [**distinto tipo y distinta longitud**]{.hl-purple}
:::

---

## Celdas: tipos de datos

¬øExisten [**variables m√°s all√° de los n√∫meros**]{.hl-yellow}?

. . .

Piensa por ejemplo en los datos guardados de una persona:

::: {.fragment .fade-up}
-   La edad o el peso ser√° un [**n√∫mero**]{.hl-yellow}.

```{r}
edad <- 33
```
:::

::: {.fragment .fade-up}
-   Su nombre ser√° una cadena de [**texto (string o char)**]{.hl-yellow}.

```{r}
nombre <- "javi"
```
:::

::: {.fragment .fade-up}
-   A la pregunta ¬´¬øest√°s matriculado en la Facultad?¬ª la respuesta ser√° lo que llamamos una [**variable l√≥gica**]{.hl-yellow} (`TRUE` si est√° matriculado o `FALSE` en otro caso).

```{r}
matriculado <- TRUE
```
:::

::: {.fragment .fade-up}
-   Su fecha de nacimiento ser√° precisamente eso, una [**fecha**]{.hl-yellow}.
:::

---

## Variables num√©ricas

El dato m√°s sencillo (ya lo hemos usado) ser√°n las [**variables num√©ricas**]{.hl-yellow}

```{r}
#| eval: false
a <- 5
b <- 2
a + b
```

```{r}
#| echo: false
#| include: false
a <- 5
b <- 2
a + b
```

. . .

Para saber el tipo de una variable tenemos la funci√≥n `class()`

```{r}
class(a)
```

. . .

Adem√°s de los n√∫meros ¬´normales¬ª tendremos el [**valor infinito**]{.hl-yellow}

```{r}
1/0
```

. . .

Y valores que [**no son n√∫meros reales**]{.hl-yellow} _not a number_ (indeterminaciones, complejos, etc)

```{r}
0/0
```


---

## Variables num√©ricas

Con las variables num√©ricas podemos realizar las [**operaciones aritm√©ticas**]{.hl-yellow} de una calculadora: sumar (`+`)...

```{r}
a + b
```

. . .

...ra√≠z cuadrada (`sqrt()`)...

```{r}
sqrt(a)
```

. . .

... potencias (`^2`, `^3`)...

```{r}
a^2
```

. . .

...valor absoluto (`abs()`), etc.

```{r}
abs(a)
```


---

## Variables de texto

Imagina que adem√°s de la edad de una persona queremos guardar su nombre: ahora la variable ser√° de tipo `character`

```{r}
nombre <- "Javier"
class(nombre)
```

. . .

Las [**cadenas de texto**]{.hl-yellow} son un tipo con el que obviamente [**no podremos hacer operaciones aritm√©ticas**]{.hl-red} (s√≠ otras operaciones como pegar o localizar patrones).

```{r}
#| error: true
nombre + 1 # error al sumar n√∫mero a texto
```

. . .

::: callout-warning
## Recuerda que...

Las variables de tipo texto (character o string) van [**SIEMPRE entre comillas**]{.hl-orange}: no es lo mismo `TRUE` (valor l√≥gico, binario) que `"TRUE"` (texto).
:::

---

## Primera funci√≥n: paste

En `R` llamaremos [**funci√≥n**]{.hl-yellow} a un trozo de [**c√≥digo encapsulado**]{.hl-yellow} bajo un nombre, y que depende de unos [**argumentos**]{.hl-yellow} de entrada. Nuestra primera funci√≥n ser√° `paste()`: dadas dos cadenas de texto nos permite pegarlas.

```{r}
paste("Javier", "√Ålvarez")
```

. . .

F√≠jate que [**por defecto**]{.hl-yellow} nos pega las cadenas con un espacio, pero podemos a√±adir un [**argumento opcional**]{.hl-yellow} para indicarle el separador (en `sep = ...`).

```{r}
paste("Javier", "√Ålvarez", sep = "*")
```

---

## Primera funci√≥n: paste

::: columns
::: {.column width="50%"}
![](img/paste_help.jpg)
:::

::: {.column width="50%"}
¬øC√≥mo saber [**qu√© argumentos necesita una funci√≥n**]{.hl-yellow}? Escribiendo en consola `? paste` te aparecer√° una [**ayuda**]{.hl-yellow} en el panel multiusos.

En dicha ayuda podr√°s ver en su cabecera que argumentos ya tiene [**asignados por defecto**]{.hl-yellow} la funci√≥n
:::
:::

. . .

Existe una funci√≥n similar llamada `paste0()` que pega por defecto con `sep = ""` (sin nada).

```{r}
paste0("Javier", "√Ålvarez")
```

--- 

## Funciones: argumentos por defecto

Es muy importante entender el concepto de [**argumento por defecto de una funci√≥n**]{.hl-yellow} en `R`: es un valor que la funci√≥n usa pero a veces podemos no ver porque [**ya tiene un valor asignado**]{.hl-yellow}. 

```{r}
# Hacen lo mismo
paste("Javier", "√Ålvarez")
paste("Javier", "√Ålvarez", sep = " ")
```

. . .

::: callout-note
## Toma nota

El operador `=` lo [**reservaremos para asignar argumentos**]{.hl-yellow} dentro de funciones. Para todas las dem√°s asignaciones usaremos `<-`
:::

---

## Primer paquete: glue

Una forma m√°s intuitiva de trabajar con textos es usar el paquete `{glue}`: lo primero que haremos ser√° ¬´comprar el libro¬ª (si nunca lo hemos hecho). Tras ello [**cargamos el paquete**]{.hl-yellow}

```{r}
#| eval: false
install.packages("glue") # solo la primra vez
library(glue)
```

```{r}
#| echo: false
library(glue)
```

. . .

Con la funci√≥n `glue()` de dicho paquete podemos usar [**variables dentro de cadenas de texto**]{.hl-yellow}. Por ejemplo, ¬´la edad es de ... a√±os¬ª, donde la edad est√° guardada en una variable.

```{r}
edad <- 33
glue("La edad es de {edad} a√±os")
```

. . .

Dentro de las llaves tambi√©n podemos [**ejecutar operaciones**]{.hl-yellow}

```{r}
unidades <- "d√≠as"
glue("La edad es de {edad * 365} {unidades}")
```

---

## Variables l√≥gicas

Otro tipo fundamental ser√°n las [**variables l√≥gicas o binarias**]{.hl-yellow} (**dos valores**):

-   `TRUE`: [**verdadero**]{.hl-yellow} guardado internamente como un 1.
-   `FALSE`: [**falso**]{.hl-yellow} guardado internamente como un 0.

```{r}
soltero <- TRUE # ¬øEs soltero? --> S√ç
class(soltero)
```

. . .

Dado que internamente est√°n guardados como variables binarias, podemos [**realizar operaciones aritm√©ticas**]{.hl-yellow} con ellas

```{r}
2 * TRUE
FALSE - 1
```

---

## Variables l√≥gicas

Como veremos en breve, las variables l√≥gicas en realidad puede tomar un tercer valor: `NA` o [**dato ausente**]{.hl-yellow}, representando las siglas de *not available*, y ser√° muy habitual encontrarlo dentro de una base de datos.

```{r}
ausente <- NA
ausente + 1
```


. . .

::: callout-important
## Importante

Las variables l√≥gicas [**NO son variables de texto**]{.hl-red}: `"TRUE"` es un texto, `TRUE` es un valor l√≥gico.

```{r}
#| error: true
TRUE + 1
"TRUE" + 1
```
:::

---

## Condiciones l√≥gicas

Los valores l√≥gicos suelen ser resultado de [**evaluar condiciones l√≥gicas**]{.hl-yellow}. Por ejemplo, imaginemos que queremos [**comprobar**]{.hl-yellow} si una persona se llama Javi.

```{r}
nombre <- "Mar√≠a"
```


. . .

Con el [**operador l√≥gico**]{.hl-yellow} `==` preguntamos s√≠ lo que tenemos guardado a la izquierda es igual que lo que tenemos a la derecha: es una [**pregunta**]{.hl-yellow}

```{r}
nombre == "Javi"
```

. . .

Con su opuesto `!=` preguntamos si es distinto.

```{r}
nombre != "Javi"
```

. . .

::: callout-note
## F√≠jate que...

No es lo mismo `<-` ([**asignaci√≥n**]{.hl-yellow}) que `==` (estamos [**preguntando**]{.hl-yellow}, es una comparaci√≥n l√≥gica).
:::

---

## Condiciones l√≥gicas

Adem√°s de las comparaciones ¬´igual a¬ª frente ¬´distinto¬ª, tambi√©n comparaciones de orden como `<, <=, > o >=`.

**¬øTiene la persona menos de 32 a√±os?**

```{r}
edad <- 34
edad < 32 # ¬øEs la edad menor de 32 a√±os?
```

. . .

**¬øLa edad es mayor o igual que 38 a√±os?**

```{r}
edad >= 38
```

. . .

**¬øEl nombre guardado es Javi?**

```{r}
nombre <- "Javi"
nombre == "Javi"
```

---

## Variables de fecha

Un tipo de datos muy especial: los [**datos de tipo fecha**]{.hl-yellow}.

```{r}
fecha_char <- "2021-04-21"
```

Parece una simple cadena de texto pero [**deber√≠a representar un instante en el tiempo**]{.hl-yellow}. ¬øQu√© deber√≠a suceder si [**sumamos un 1 a una fecha**]{.hl-purple}?

. . .

```{r}
#| error: true
fecha_char + 1
```


Las fechas [**NO pueden ser texto**]{.hl-red}: debemos convertir la cadena de texto a fecha.

. . .

&nbsp;

Para trabajar con fechas usaremos el paquete `{lubridate}`, que deberemos instalar antes de poder usarlo.

```{r}
#| eval: false
install.packages("lubridate")
```

---

## Variables de fecha

Una vez instalado, de todos los paquetes (libros) que tenemos, le indicaremos que nos cargue ese concretamente.

```{r}
library(lubridate) # instala si no lo has hecho

```

. . .

Para [**convertir a tipo fecha**]{.hl-yellow} usaremos la funci√≥n `as_date()` del paquete `{lubridate}`

&nbsp;

:::: columns
::: {.column width="50%"}

```{r}
#| error: true
# ¬°no es una fecha, es un texto!
fecha_char + 1
class(fecha_char)
```

:::

::: {.column width="50%"}

```{r}
fecha <- as_date("2023-03-28")
fecha + 1
class(fecha)
```

:::

::::

---

## Variables de fecha

En dicho paquete tenemos funciones muy √∫tiles para [**manejar fechas**]{.hl-yellow}:

-   Con `today()` podemos obtener directamente la [**fecha actual**]{.hl-purple}.

```{r}
today()
```

. . .

-   Con `now()` podemos obtener la [**fecha y hora actual**]{.hl-purple}

```{r}
now()
```

. . .

-   Con `year()`, `month()` o `day()` podemos [**extraer el a√±o, mes y d√≠a**]{.hl-purple}

```{r}
fecha <- today()
year(fecha)
month(fecha)
```

---

## Res√∫menes de paquetes

![](img/lubridate.png)

::: callout-note
## Amplia contenido

Tienes un resumen en pdf de los paquetes m√°s importantes en la [**carpeta correspondiente en el campus**]{.hl-green}
:::

---

## üíª Tu turno {#tu-turno-1}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

üìù Define una variable que guarde tu edad (llamada `edad`) y otra con tu nombre (llamada `nombre`)

```{r}
#| code-fold: true
edad <- 33
nombre <- "Javi"
```

### [**Ejercicio 2**]{.hl-yellow}

üìù Comprueba si NO tienes 60 a√±os o si te llamas "Ornitorrinco" (debes obtener variables l√≥gicas)

```{r}
#| code-fold: true
#| eval: false
edad != 60 # distinto de
nombre == "Ornitorrinco" # igual a
```

### [**Ejercicio 3**]{.hl-yellow}

üìù Define otra variable llamada `hermanos` que responda la pregunta ¬´¬øtienes hermanos?¬ª y otra variable que almacene tu fecha de nacimiento (llamada `fecha_nacimiento`).

```{r}
#| code-fold: true
hermanos <- TRUE

library(lubridate) # sino lo ten√≠as ya cargado
fecha_nacimiento <- as_date("1989-09-10")
```

### [**Ejercicio 4**]{.hl-yellow}

üìù Define otra variable con tus apellidos (llamada `apellidos`) y usa `glue()` para tener, en una sola variable  llamada `nombre_completo`, tu nombre y apellidos separando nombre y apellido por una coma

```{r}
#| code-fold: true
#| eval: false
apellidos <- "√Ålvarez Li√©bana"
glue("{nombre}, {apellidos}")
```

### [**Ejercicio 5**]{.hl-yellow}

üìù De `fecha_nacimiento` extrae el mes.

```{r}
#| code-fold: true
#| eval: false
month(fecha_nacimiento)
```

### [**Ejercicio 6**]{.hl-yellow}

üìù Calcula los d√≠as que han pasado desde la fecha de tu nacimiento hasta hoy (con la fecha de nacimiento definida en el ejercicio 3).

```{r}
#| code-fold: true
#| eval: false
today() - fecha_nacimiento
```
:::

---

## Vectores: concatenar

Cuando trabajamos con datos normalmente tendremos [**columnas que representan variables**]{.hl-yellow}: llamaremos [**vectores**]{.hl-yellow} a una [**concatenaci√≥n**]{.hl-purple} de celdas (valores) del [**mismo tipo**]{.hl-purple} (lo que ser√≠a una columna de una tabla).

. . .

La forma m√°s sencilla es con el comando `c()` (c de **concatenar**), y basta con introducir sus **elementos entre par√©ntesis y separados por comas**

```{r}
edades <- c(32, 27, 60, 61)
edades
```

. . .

::: callout-tip
Un n√∫mero individual `x <- 1` (o bien `x <- c(1)`) es en realidad un **vector de longitud uno** --> todo lo que sepamos [**hacer con un n√∫mero podemos hacerlo con un vector de ellos**]{.hl-green}.
:::

---

## Vectores: concatenar

::: columns
::: {.column width="40%"}
![](img/edades_environment.jpg)
:::

::: {.column width="60%"}
Como ves ahora en el `environment` tenemos una **colecci√≥n de elementos** guardada

```{r}
edades
```
:::
:::

. . .



La [**longitud de un vector**]{.hl-yellow} se puede calcular con `length()`

```{r}
length(edades)
```

. . .

Tambi√©n podemos [**concatenar vectores**]{.hl-yellow} entre s√≠ (los repite uno tras otro)

```{r}
c(edades, edades, 8)
```

---

## Secuencias num√©ricas

El vector m√°s famoso ser√° el de tipo num√©rico, y en concreto, las conocidas como [**secuencias num√©ricas**]{.hl-yellow} (por ejemplo, los d√≠as del mes), usadas para, entre otras cosas, indexar bucles.

. . .

El comando `seq(inicio, fin)` nos permite crear una [**secuencia num√©rica**]{.hl-yellow} desde un elemento inicial hasta uno final, [**avanzando de uno en uno**]{.hl-purple}.

```{r}
seq(1, 31)
```

. . .

F√≠jate que si hacemos eso con [**caracteres no podremos hacerlo**]{.hl-red} ya que no hay un orden a priori entre textos.

```{r}
#| error: true
"a":"z"
```

---

## Secuencias num√©ricas


Un atajo es el comando `1:n`, que nos devuelve lo mismo que `seq(1, n)`

```{r}
1:7
```

Si el elemento inicial es mayor que el final, entender√° que la secuencia es [**en orden decreciente**]{.hl-purple}.

```{r}
7:-3
```

. . .

Tambi√©n podemos definir [**otro tipo de distancia**]{.hl-yellow} (paso) entre consecutivos con el argumento `by = ...`

```{r}
seq(1, 7, by = 0.5) # secuencia desde 1 a 7 de 0.5 en 0.5
```

---

## Secuencias num√©ricas


Otras veces nos interesar√° definir una [**secuencia con una longitud concreta**]{.hl-yellow}

```{r}
seq(1, 50, l = 7) # secuencia desde 1 a 50 de longitud 7
```

. . .

Incluso puede nos interese generar un vector de [**n elementos repetidos**]{.hl-yellow}

```{r}
rep(0, 7) # vector de 7 ceros
```

. . .


Dado que internamente son guardados como n√∫meros tambi√©n podremos hacer esto con [**fechas**]{.hl-yellow}.

```{r}
seq(as_date("2023-09-01"), as_date("2023-09-10"), by = 1)
```


---

## Vectores de caracteres

Un vector es una **concatenaci√≥n** de elementos del [**mismo tipo**]{.hl-yellow}, pero no tienen porque ser necesariamente n√∫meros. Vamos a crear una frase de ejemplo.

```{r}
frase <- "Me llamo Javi"
frase
length(frase)
```

. . .

En el caso anterior no era un vector, era un solo elemento de texto. Para crear un vector debemos usar de nuevo `c()` y separar elementos entre comas

```{r}
vector <- c("Me", "llamo", "Javi")
vector
length(vector)
```

---

## Vectores de caracteres

¬øQu√© suceder√° si [**concatenamos elementos de diferente tipo**]{.hl-yellow}?

. . .

```{r}
c(1, 2, "javi", "3", TRUE)
```

F√≠jate que como todos tienen que ser del mismo tipo, lo que hace `R` es [**convertir**]{.hl-yellow} todo a texto, violando la [**integridad del dato**]{.hl-red}

. . .

```{r}
c(3, 4, TRUE, FALSE)
```

Es importante entender que los valores l√≥gicos en realidad est√°n [**almacenados internamente como 0/1**]{.hl-yellow}

---

## Operaciones con vectores

Con los vectores num√©ricos podemos hacer las mismas [**operaciones aritm√©ticas**]{.hl-yellow} que con los n√∫meros ‚Üí un [**n√∫mero es un vector**]{.hl-purple} (de longitud uno)

. . .

¬øQu√© suceder√° si [**sumamos o restamos un valor**]{.hl-yellow} a un vector?

. . .

```{r}
x <- c(1, 3, 5, 7)
x + 1
x * 2
```

::: callout-warning
## Cuidado

Salvo que indiquemos lo contrario, en `R` las operaciones con vectores son siempre [**elemento a elemento**]{.hl-orange}
:::

---

## Operaciones con vectores

Los vectores tambi√©n pueden interactuar entre ellos, as√≠ que podemos definir, por ejemplo, [**sumas de vectores**]{.hl-yellow} (elemento a elemento)

```{r}
x <- c(2, 4, 6)
y <- c(1, 3, 5)
x + y
```

. . .

Dado que la operaci√≥n (por ejemplo, una suma) se realiza elemento a elemento, ¬øqu√© suceder√° si [**sumamos dos vectores de distinta longitud**]{.hl-yellow}?

. . .

```{r}
z <- c(1, 3, 5, 7)
x + z
```

Lo que hace es [**reciclar elementos**]{.hl-yellow}: si tiene un vector de 4 elementos y sumamos otro de 3 elementos, lo que har√° ser√° reciclar del vector con menor longitud.

---

## Operaciones con vectores

Una operaci√≥n muy habitual es [**preguntar a los datos**]{.hl-yellow} mediante el uso de [**condiciones l√≥gicas**]{.hl-purple}. Por ejemplo, si definimos un vector de temperaturas...

[**¬øQu√© d√≠as hizo menos de 22 grados?**]{.hl-yellow}

```{r}
x <- c(15, 20, 31, 27, 15, 29)
```

. . .

```{r}
x < 22
```

Nos devolver√° un [**vector l√≥gico**]{.hl-yellow}, en funci√≥n de si **cada elemento** cumple o no la condici√≥n pedida (de **igual longitud** que el vector preguntado)

. . .

Si tuvi√©ramos un [**dato ausente**]{.hl-yellow} (por error del aparato ese d√≠a), la condici√≥n evaluada tambi√©n ser√≠a `NA`

```{r}
y <- c(15, 20, NA, 31, 27, 7, 29, 10)
y < 22
```

---

## Operaciones con vectores

Las [**condiciones l√≥gicas pueden ser combinadas**]{.hl-yellow} de dos maneras:

-   [**Intersecci√≥n**]{.hl-yellow}: [**todas**]{.hl-purple} las condiciones concatenadas se deben cumplir ([**conjunci√≥n y**]{.hl-purple} con `&`) para devolver un `TRUE`

```{r}
x < 30 & x > 15
```

-   [**Uni√≥n**]{.hl-yellow}: basta con que [**al menos una**]{.hl-purple} se cumpla ([**conjunci√≥n o**]{.hl-purple} con `|`)

```{r}
x < 30 | x > 15
```

. . .

Con `any()` y `all()` podemos comprobar que [**todos los elementos**]{.hl-yellow} cumplen

```{r}
any(x < 30)
all(x < 30)
```

---

## Operaciones con vectores

Otra operaci√≥n muy habitual es la de [**acceder a elementos**]{.hl-yellow}. La forma m√°s sencilla es usar el operador `[i]` (acceder al elemento i-√©simo)

```{r}
edades <- c(20, 30, 33, NA, 61) 
edades[3] # accedemos a la edad de la tercera persona 
```

. . .


Dado que un n√∫mero no es m√°s que un vector de longitud uno, esta operaci√≥n tambi√©n la podemos aplicar usando un [**vector de √≠ndices a seleccionar**]{.hl-yellow}

```{r}
y <- c("hola", "qu√©", "tal", "est√°s", "?")
y[c(1:2, 4)] # primer, segundo y cuarto elemento
```

. . .

::: callout-tip
Para acceder al √∫ltimo, sin preocuparnos de cu√°l es, podemos pasarle como √≠ndice la propia longitud `x[length(x)]`
:::

---

## Operaciones con vectores

Otras veces no querremos seleccionar sino [**eliminar algunos elementos**]{.hl-yellow}. Deberemos repetir la misma operaci√≥n pero con el signo - delante: el operador `[-i]` no selecciona el elemento i-√©simo del vector sino que lo ¬´des-selecciona¬ª

```{r}
y
y[-2]
```


. . .

En muchas ocasiones los queremos [**seleccionar o eliminar en base a condiciones l√≥gicas**]{.hl-yellow}, en funci√≥n de los valores, as√≠ que pasaremos como √≠ndice la propia condici√≥n (recuerda, `x < 2` nos devuelve un vector l√≥gico)

```{r}
edades <- c(15, 21, 30, 17, 45)
nombres <- c("javi", "mar√≠a", "laura", "carla", "luis")
nombres[edades < 18] # nombres de los menores de edad
```

---


## üíª Tu turno {#tu-turno-2}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

üìù Define el vector `x` como la concatenaci√≥n de los 5 primeros n√∫meros impares. Calcula la longitud del vector

```{r}
#| code-fold: true
#| eval: false
# Dos formas
x <- c(1, 3, 5, 7, 9)
x <- seq(1, 9, by = 2)

length(x)
```

### [**Ejercicio 2**]{.hl-yellow}

üìù Accede al tercer elemento. Accede al √∫ltimo elemento (sin importar la longitud, un c√≥digo que pueda ejecutarse siempre). Elimina el primer elemento.

```{r}
#| code-fold: true
#| eval: false
x[3]
x[length(x)]
x[-1]
```

### [**Ejercicio 3**]{.hl-yellow}

üìù Obt√©n de dicho vector los elementos de `x` mayores que 4. Calcula el vector `1/x` y gu√°rdalo en una variable.

```{r}
#| code-fold: true
#| eval: false
x[x > 4]
z <- 1/x
z
```

### [**Ejercicio 4**]{.hl-yellow}

üìù Crea un vector que represente los nombres de 5 personas, de los cuales uno es desconocido.

```{r}
#| code-fold: true
#| eval: false
nombres <- c("Javi", "Sandra", NA, "Laura", "Carlos")
nombres
```

### [**Ejercicio 5**]{.hl-yellow}

üìù Encuentra del vector `x` de ejercicios anteriores los elementos mayores (estrictos) que 1 Y ADEM√ÅS menores (estrictos) que 7. Encuentra una forma de averiguar si todos los elementos son o no positivos.

```{r}
#| code-fold: true
#| eval: false
x[x > 1 & x < 7]
all(x > 0)
```

### [**Ejercicio 6**]{.hl-yellow}

üìù Dado el vector `x <- c(1, -5, 8, NA, 10, -3, 9)`, extrae los elementos que ocupan los lugares 1, 2, 5, 6. Elimina del vector el segundo elemento. Tras eliminarlo determina su suma y su media

```{r}
#| code-fold: true
#| eval: false
x <- c(1, -5, 8, NA, 10, -3, 9)
x[c(1, 2, 5, 6)]
x[-2]
```

### [**Ejercicio 7**]{.hl-yellow}

üìù Dado el vector del ejercicio anterior, ¬øcuales tienen un dato ausente? Pista: las funciones `is.algo()` comprueban si el elemento es tipo `algo`. Busca en internet como comprobar que un dato es ausente o escribe `is.` en consola y tabula.

```{r}
#| code-fold: true
#| eval: false
is.na(x)
```

:::

---


## üê£ Caso pr√°ctico {#caso-pr√°ctico-2}

En el paquete `{datasets}` tenemos diversos conjuntos de datos y uno de ellos es `airquality`. Debajo te he extra√≠do 3 variables de dicho dataset

```{r}
temperature <- airquality$Temp
month <- airquality$Month
day <- airquality$Day
```

1. ¬øQu√© [**representan los datos**]{.hl-yellow}? ¬øC√≥mo averiguarlo?

```{r}
#| code-fold: true
#| eval: false
? airquality
```

Haciendo uso de `? ...` podemos consultar en el panel de ayuda lo que significa el objeto.

---

## üê£ Caso pr√°ctico {#caso-pr√°ctico-2-2}

2. ¬øCu√°ntos [**registros tenemos de mayo**]{.hl-yellow}? ¬øY de abril? Construye una nueva variable `date` con la [**fecha**]{.hl-yellow} de cada registro (combinando a√±o, mes y d√≠a)

```{r}
#| code-fold: true
# Una forma para registros de mayo
sum(month == 5)
# Otra forma
length(month[month == 5])

# √≠dem en abril
sum(month == 4)

# variable date
dates <- lubridate::as_date(glue("{1973}-{month}-{day}"))
```

. . .

3. Crea una nueva variable `temp_celsius` con la [**temperatura en ¬∫C**]{.hl-yellow}

```{r}
#| code-fold: true
# Temperatura en celsius
temp_celsius <- (temperature - 32) * (5/9)
```

---

## üê£ Caso pr√°ctico {#caso-pr√°ctico-2-3}

4. ¬øCu√°l fue la [**media de temperatura**]{.hl-yellow} del mes de agosto? Extrae los d√≠as en los que la [**temperatura super√≥ los 30 grados**]{.hl-yellow} y calcula la cantidad de d√≠as en los que lo hizo.

```{r}
#| code-fold: true
# media en agosto
mean(temperature[month == 8], na.rm = TRUE)
mean(temp_celsius[month == 8], na.rm = TRUE)

# Extremos d√≠as > 30
dates[temp_celsius > 30]
length(dates[temp_celsius > 30]) # n d√≠as
sum(temp_celsius > 30) # n d√≠as (otra forma)
```

---


## Operaciones con vectores

Tambi√©n podemos hacer uso de [**operaciones estad√≠sticas**]{.hl-yellow} como por ejemplo `sum()` que, dado un vector, nos devuelve la suma de todos sus elementos.

```{r}
x <- c(1, -2, 3, -1)
sum(x)
```

[**¬øQu√© sucede cuando falta un dato (ausente)?**]{.hl-yellow}

. . .

```{r}
x <- c(1, -2, 3, NA, -1)
sum(x)
```

Por defecto, si tenemos un dato ausente, la [**operaci√≥n tambi√©n ser√° ausente**]{.hl-yellow}. Para poder [**obviar ese dato**]{.hl-purple}, usamos un argumento opcional `na.rm = TRUE`

```{r}
sum(x, na.rm = TRUE)
```

---

## Operaciones con vectores

Como hemos comentado que los valores l√≥gicos son guardados internamente como 0 y 1, podremos usarlos en operaciones aritm√©ticas.


Por ejemplo, si queremos [**averiguar el n√∫mero de elementos que cumplen una condici√≥n**]{.hl-yellow} (por ejemplo, menores que 3), los que lo hagan tendr√°n asignado un 1 (`TRUE`) y los que no un 0 (`FALSE`) , por lo que basta con sumar dicho vector l√≥gico para obtener el n√∫mero de elementos que cumplen

```{r}
x <- c(2, 4, 6)
sum(x < 3)
```

---

## Operaciones con vectores

Otra operaci√≥n habitual que puede sernos √∫til es la [**suma acumulada**]{.hl-yellow} con `cumsum()` que, dado un vector, nos devuelve un vector a su vez con el primero, el primero m√°s el segundo, el primero m√°s el segundo m√°s el tercero...y as√≠ sucesivamente.

```{r}
x <- c(1, 5, 2, -1, 8)
cumsum(x)
```

[**¬øQu√© sucede cuando falta un dato (ausente)?**]{.hl-yellow}

. . .

```{r}
x <- c(1, -2, 3, NA, -1)
cumsum(x)
```

En el caso de la suma acumulada lo que sucede es que [**a partir de ese valor, todo lo acumulado posterior ser√° ausente**]{.hl-yellow}.

---

## Operaciones con vectores

Otra operaci√≥n habitual que puede sernos √∫til es la [**diferencia (con retardo)**]{.hl-yellow} con `diff()` que, dado un vector, nos devuelve un vector con el segundo menos el primero, el tercero menos el segundo, el cuarto menos el tercero...y as√≠ sucesivamente.


```{r}
x <- c(1, 8, 5, 3, 9, 0, -1, 5)
diff(x)
```

. . .

Con el argumento `lag = ` podemos indicar el [**retardo**]{.hl-yellow} de dicha diferencia (por ejemplo, `lag = 3` implica que se resta el cuarto menos el primero, el quinto menos el segundo, etc)


```{r}
x <- c(1, 8, 5, 3, 9, 0, -1, 5)
diff(x, lag = 3)
```

---

## Operaciones con vectores

Otras operaciones habituales son la [**media**]{.hl-yellow}, [**mediana**]{.hl-yellow}, [**percentiles**]{.hl-yellow}, etc.

-   [**Media**]{.hl-yellow}: medida de centralidad que consiste en sumar todos los elementos y dividirlos entre la cantidad de elementos sumados. La m√°s conocida pero la [**menos robusta**]{.hl-red}: dado un conjunto, si se introducen valores at√≠picos o outliers (valores muy grandes o muy peque√±os), la media se perturba con mucha facilidad.

```{r}
x <- c(165, 170, 181, 191, 150, 155, 167, NA, 173, 177)
mean(x, na.rm = TRUE)
```

---

## Operaciones con vectores

Otras operaciones habituales son la [**media**]{.hl-yellow}, [**mediana**]{.hl-yellow}, [**percentiles**]{.hl-yellow}, etc.


-   [**Mediana**]{.hl-yellow}: medida de centralidad que consiste en ordenar los elementos y quedarse con el que ocupa la mitad.

```{r}
x <- c(165, 170, 181, 191, 150, 155, 167, 173, 177)
median(x)
```

. . .

-   [**Percentiles**]{.hl-yellow}: medidas de posici√≥n (nos dividen en partes iguales los datos).

```{r}
quantile(x) # por defecto percentiles 0-25-50-75-100
quantile(x, probs = c(0.1, 0.4, 0.9))
```

# Clase 3: primeras bases de datos {#clase-3}

[**Variables de tipo texto. Primeras bases de datos**]{style="color:#444442;"}


---

## √öltima operaci√≥n: ordenar

Por √∫ltimo, una acci√≥n habitual es saber [**ordenar valores**]{.hl-yellow}:

-   `sort()`: devuelve el [**vector ordenado**]{.hl-yellow}. Por defecto de menor a mayor pero con `decreasing = TRUE` podemos cambiarlo

```{r}
edades <- c(81, 7, 25, 41, 65, 20, 33, 23, 77)
sort(edades)
sort(edades, decreasing = TRUE)
```

. . .

-   `order()`: devuelve el [**vector de √≠ndices**]{.hl-yellow} que tendr√≠amos que usar para tener el vector ordenado

```{r}
order(x)
x[order(x)]
```

---

## üíª Tu turno {#tu-turno-3}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

üìù Define el vector `x` como la concatenaci√≥n de los 4 primeros n√∫meros pares, y calcula su suma.

```{r}
#| code-fold: true
#| eval: false
# Dos formas
x <- c(2, 4, 6, 8)
x <- seq(2, 8, by = 2)

sum(x)
```

### [**Ejercicio 2**]{.hl-yellow}

üìù Obt√©n los elementos de `x` menores estrictamente que 5. Calcula el n√∫mero de elementos de `x` menores estrictamente que 5.

```{r}
#| code-fold: true
#| eval: false
x[x < 5] 
sum(x < 5)
```

### [**Ejercicio 3**]{.hl-yellow}

üìù Calcula el vector `1/x` y obt√©n la versi√≥n ordenada (de menor a mayor) de las dos formas posibles

```{r}
#| code-fold: true
#| eval: false
z <- 1/x
sort(z)
z[order(z)]
```

### [**Ejercicio 4**]{.hl-yellow}

üìù Encuentra el m√°ximo y el m√≠nimo del vector `x`

```{r}
#| code-fold: true
#| eval: false
min(x)
max(x)
```

### [**Ejercicio 5**]{.hl-yellow}

üìù Encuentra del vector `x` los elementos mayores (estrictos) que 1 y menores (estrictos) que 6. Encuentra una forma de averiguar si todos los elementos son o no negativos.

```{r}
#| code-fold: true
#| eval: false
x[x > 1 & x < 7]
all(x > 0)
```

### [**Ejercicio 6**]{.hl-yellow}

üìù Dado el vector `x <- c(1, -5, 8, NA, 10, -3, 9)`, calcula su suma y su media de forma que devuelva un valor num√©rico conocido.

```{r}
#| code-fold: true
#| eval: false
x <- c(1, -5, 8, NA, 10, -3, 9)
sum(x, na.rm = TRUE)
mean(x, na.rm = TRUE)
```
:::

---


## Primera base de datos: matrices

Cuando analizamos datos solemos tener [**varias variables**]{.hl-yellow} de cada individuo: necesitamos una ¬´tabla¬ª que las recopile. La opci√≥n m√°s inmediata son las [**matrices**]{.hl-yellow}: concatenaci√≥n de variables del [**mismo tipo e igual longitud**]{.hl-purple}.

. . .

Imagina que tenemos estaturas y pesos de 4 personas. ¬øC√≥mo [**crear un dataset con las dos variables**]{.hl-yellow}?

-   Con `cbind()` [**concatenamos vectores en forma de columnas**]{.hl-yellow}

```{r}
estaturas <- c(150, 160, 170, 180)
pesos <- c(63, 70, 85, 95)
datos_matriz <- cbind(estaturas, pesos)
datos_matriz
```

---

## Primer intento: matrices

-   Tambi√©n podemos [**construir la matriz por filas**]{.hl-yellow} con la funci√≥n `rbind()` (aunque lo recomendable es tener cada variable en columna e individuo en fila).

```{r}
# Construimos la matriz por filas
rbind(estaturas, pesos)
```

. . .

-   Podemos [**visualizar la matriz**]{.hl-yellow} con la funci√≥n `View()`.

. . .

-   Podemos [**comprobar las dimensiones**]{.hl-yellow} con `dim()`, `nrow()` y `ncol()`: nuestros datos est√°n tabulados:

```{r}
dim(datos_matriz)
nrow(datos_matriz)
```

---

## Primer intento: matrices

-   Tambi√©n podemos [**¬´darle vuelta¬ª (matriz transpuesta)**]{.hl-yellow} con `t()`.

```{r}
t(datos_matriz)
```

. . .

-   Dado que ahora tenemos dos dimensiones, para [**acceder a elementos**]{.hl-yellow} deberemos proporcionar el √≠ndice de la fila y de la columna (si quedan libres implica todos de esa dimensi√≥n)

```{r}
datos_matriz[2, 1]
datos_matriz[, 2]
```

---

## Primer intento: matrices

-   Tambi√©n podemos definir una [**matriz a partir de un vector num√©rico**]{.hl-yellow}, reorganizando los valores en forma de matriz (sabiendo que los elementos se van [**colocando por columnas**]{.hl-purple}).

```{r}
z <- matrix(1:15, ncol = 5) 
z
```

---

## Primer intento: matrices

Con las matrices sucede como con los vectores: cuando aplicamos una [**operaci√≥n aritm√©tica lo hacemos elemento a elemento**]{.hl-yellow}

```{r}
z/5
```

. . .

Para realizar [**operaciones en un sentido matricial**]{.hl-yellow} deberemos a√±adir `%%`, por ejemplo, para multiplicar matrices ser√° `%*%`


```{r}
z %*% t(z)
```


---

## Primer intento: matrices

Tambi√©n podemos [**realizar operaciones por columnas/filas**]{.hl-yellow} sin recurrir a bucles con la funci√≥n `apply()`, y le indicaremos como **argumentos**

-   la matriz
-   el sentido de la operaci√≥n (MARGIN = 1 por filas, MARGIN = 2 por columnas)
-   la funci√≥n a aplicar

. . .

```{r}
# Media (mean) por columnas (MARGIN = 2)
apply(datos_matriz, MARGIN = 2, FUN = "mean")
```

. . .

```{r}
# (Cuasi)varianza (var) por columnas (MARGIN = 2)
apply(datos_matriz, MARGIN = 2, FUN = "var")
```


---

## üíª Tu turno (matrices) {#tu-turno-matrices}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

üìù Modifica el c√≥digo para definir una matriz `x` de ceros de 3 filas y 7 columnas de unos.

```{r}
#| eval: false
x <- matrix(0, nrow = 2, ncol = 3)
x
```

```{r}
#| code-fold: true
#| eval: false
x <- matrix(1, nrow = 3, ncol = 7)
x
```

### [**Ejercicio 2**]{.hl-yellow}

üìù A la matriz anterior, suma un 1 a cada n√∫mero de la matriz y divide el resultado entre 5. Tras ello calcula su transpuesta y obt√©n sus dimensiones

```{r}
#| code-fold: true
#| eval: false
new_matrix <- (x + 1)/5
t(new_matrix)
dim(new_matrix)
```

### [**Ejercicio 3**]{.hl-yellow}

üìù Define la matriz `x <- matrix(1:12, nrow = 4)`. Obt√©n la primera fila, la tercera columna, y el elemento (4, 1).

```{r}
#| code-fold: true
#| eval: false
x <- matrix(1:12, nrow = 4)
x[1, ] # primera fila
x[, 3] # tercera columna
x[4, 1] # elemento (4, 1)
```

### [**Ejercicio 4**]{.hl-yellow}

üìù Con la matriz anterior definida como `x <- matrix(1:12, nrow = 4)`, calcula la media de todos los elementos, la media de cada fila y la media de cada columna. Calcula la suma de de cada fila y de cada columna

```{r}
#| code-fold: true
#| eval: false
x <- matrix(1:12, nrow = 4)
mean(x) # de todos
apply(x, MARGIN = 1, FUN = "mean") # media por filas
apply(x, MARGIN = 2, FUN = "mean") # media por columnas
apply(x, MARGIN = 1, FUN = "sum") # suma por filas
apply(x, MARGIN = 2, FUN = "sum") # suma por columnas

```
:::

---

## Segundo intento: data.frame

Las matrices tienen el mismo problema que los vectores: si juntamos datos de distinto tipo, se [**perturba la integridad del dato**]{.hl-red} ya que los convierte

```{r}
#| code-line-numbers: "4-5"
edades <- c(14, 24, NA)
soltero <- c(TRUE, NA, FALSE)
nombres <- c("javi", "laura", "luc√≠a")
matriz <- cbind(edades, soltero, nombres)
matriz
```

. . .

Al ya no ser n√∫meros no podemos realizar operaciones aritm√©ticas

```{r}
#| error: true
matriz + 1
```

---

## Segundo intento: data.frame

Para poder trabajar con [**variables de distinto tipo**]{.hl-yellow} tenemos lo que se conoce como [**data.frame**]{.hl-yellow}: concatenaci√≥n de variables de igual longitud pero pueden ser de [**tipo distinto**]{.hl-purple}.

```{r}
#| code-line-numbers: "1"
tabla <- data.frame(edades, soltero, nombres)
class(tabla)
tabla
```

---

## Segundo intento: data.frame

Dado que un `data.frame` es ya una ¬´base de datos¬ª las variables no son meros vectores matem√°ticos: [**tienen un significado**]{.hl-yellow} y podemos (debemos) [**ponerles nombres**]{.hl-purple}

```{r}
library(lubridate)
tabla <- data.frame("edad" = edades, "estado" = soltero, "nombre" = nombres,
             "f_nacimiento" = as_date(c("1989-09-10", "1992-04-01", "1980-11-27")))
tabla
```

---

## Segundo intento: data.frame

[**¬°TENEMOS NUESTRO PRIMER CONJUNTO DE DATOS!**]{.hl-yellow} Puedes visualizarlo escribiendo su nombre en consola o con `View(tabla)`

![](img/view_tabla.jpg)

---

## Segundo intento: data.frame

Si queremos acceder a sus elementos, podemos como en las matrices (aunque no es recomendable): ahora [**tenemos dos √≠ndices**]{.hl-yellow} (filas y columnas, dejando libre la que no usemos)

```{r}
tabla[2, ]  # segunda fila (todas sus variables)
tabla[, 3]  # tercera columna (de todos los individuos)
tabla[2, 1]  # primera caracter√≠stica de la segunda persona
```

. . .

::: columns
::: {.column width="25%"}
![](img/menu_data_frame.jpg)
:::

::: {.column width="75%"}
Tambi√©n tiene ventajas de una [**¬´base¬ª de datos**]{.hl-yellow} : podemos [**aceder a las variables por su nombre**]{.hl-purple} (**recomendable** ya que las variables pueden cambiar de posici√≥n), poniendo el nombre de la tabla seguido del s√≠mbolo `$` (con el **tabulador**, nos aparecer√° un men√∫ de columnas a elegir)
:::
:::

---

## Segundo intento: data.frame

-   `names()`: nos muestra los nombres de las variables

```{r}
names(tabla)
```

. . .

-   `dim()`: nos muestra las dimensiones (tambi√©n `nrow()` y `ncol()`)

```{r}
dim(tabla)
```

. . .

-   Podemos acceder a las variables por su nombre

```{r}
tabla[c(1, 3), "nombre"]
```

---

## Segundo intento: data.frame

Si tenemos uno ya creado y queremos [**a√±adir una columna**]{.hl-yellow} es tan simple como usar la funci√≥n `data.frame()` que ya hemos visto para concatenar la columna. Vamos a√±adir por ejemplo una nueva variable, el n√∫mero de hermanos de cada individuo.

```{r}
# A√±adimos una nueva columna con n¬∫ de hermanos/as
hermanos <- c(0, 2, 3)
tabla <- data.frame(tabla, "n_hermanos" = hermanos)
tabla
```

---

## Intento final: tibble

Las tablas en formato `data.frame` tienen algunas [**limitaciones**]{.hl-red}

La principal es que [**no permite la recursividad**]{.hl-red}: imagina que definimos una base de datos con estaturas y pesos, y queremos una tercera variable con el IMC

```{r}
#| error: true
data.frame("estatura" = c(1.7, 1.8, 1.6), "peso" = c(80, 75, 70),
           "IMC" = peso / (estatura^2))
```

. . .

¬†

De ahora en adelante usaremos el formato `tibble` (un [**data.frame mejorado**]{.hl-yellow})

```{r}
library(tibble)
tibble("estatura" = c(1.7, 1.8, 1.6), "peso" = c(80, 75, 70),
       "IMC" = peso / (estatura^2))
```

---

## Intento final: tibble

```{r}
tabla <- tibble("estatura" = c(1.7, 1.8, 1.6), "peso" = c(80, 75, 70),
                "IMC" = peso / (estatura^2))
tabla
```

Las tablas en formato `tibble` nos permitir√° una [**gesti√≥n m√°s √°gil, eficiente y coherente**]{.hl-yellow} de los datos, con 4 ventajas principales:

. . .

-   [**Metainformaci√≥n**]{.hl-yellow}: si te fijas en la cabecera, nos dice ya autom√°ticamente el n√∫mero de filas y columnas, y el tipo de cada variable

. . .

-   [**Recursividad**]{.hl-yellow}: permite definir las variables secuencialmente (como hemos visto)

---

## Intento final: tibble

-   [**Consistencia**]{.hl-yellow}: si accedes a una columna que no existe avisa con un warning

```{r}
#| warning: true
tabla$invent
```

. . .

-   [**Por filas**]{.hl-yellow}: crear por filas (copiar y pegar de una tabla) con `tribble()`

```{r}
tribble(~colA, ~colB,
        "a",   1,
        "b",   2)
```

. . .

::: callout-tip
El paquete `{datapasta}` nos permite [**copiar y pegar**]{.hl-green} tablas de p√°ginas web y documentos sencillos
:::


---

## üíª Tu turno (tibble) {#tu-turno-tibble}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

üìù Carga del paquete `{datasets}` el conjunto de datos `airquality` (variables de la calidad del aire de Nueva York desde mayo hasta septiembre de 1973). ¬øEs el conjunto de datos airquality de tipo tibble? En caso negativo, convi√©rtelo a tibble (busca en la documentaci√≥n del paquete en <https://tibble.tidyverse.org/index.html>).

```{r}
#| code-fold: true
#| eval: false
library(tibble)
class(datasets::airquality)
airquality_tb <- as_tibble(datasets::airquality)
```

### [**Ejercicio 2**]{.hl-yellow}

üìù Una vez convertido a `tibble` obt√©n el nombre de las variables y las dimensiones del conjunto de datos. ¬øCu√°ntas variables hay? ¬øCu√°ntos d√≠as se han medido?

```{r}
#| code-fold: true
#| eval: false
names(airquality_tb)
ncol(airquality_tb)
nrow(airquality_tb)
```

### [**Ejercicio 3**]{.hl-yellow}

üìù Filtra solo los datos del mes de agosto.

```{r}
#| code-fold: true
#| eval: false
airquality_tb[Month == 8, ]
```

### [**Ejercicio 4**]{.hl-yellow}

üìù Selecciona aquellos datos que no sean ni de julio ni de agosto.

```{r}
#| code-fold: true
#| eval: false
airquality_tb[Month %in% c(7, 8), ]
```

### [**Ejercicio 5**]{.hl-yellow}

üìù Modifica el siguiente c√≥digo para quedarte solo con las variable de ozono y temperatura.

```{r}
#| code-fold: true
#| eval: false
airquality_tb[, c("Ozone", "Temp")]
```

### [**Ejercicio 6**]{.hl-yellow}

üìù Selecciona los datos de temperatura y viento de agosto. Traduce a castellano el nombre de las columnas del conjunto filtrado.

```{r}
#| code-fold: true
#| eval: false
airquality_tb[Month == 8, c("Temp", "Wind")]
names(airquality_tb) <- c("ozono", "rad_solar", "viento", "temp", "mes", "dia") 
```
:::

---

## Resumen hasta ahora

-   Cada [**celda puede ser de un tipo diverso**]{.hl-yellow}: n√∫meros, texto, fechas, valores l√≥gicos, etc

. . .

-   Un [**vector es una concatenaci√≥n de celdas**]{.hl-yellow} (las futuras columnas de nuestras tablas) --\> En `R` por defecto las operaciones se hacen [**elemento a elemento**]{.hl-yellow}

. . .

-   Una [**matriz**]{.hl-yellow} nos permite concatenar [**variables del MISMO tipo y MISMA longitud**]{.hl-yellow} --\> objeto bidimensional (dos √≠ndices)

. . .

-   Un [**data.frame**]{.hl-yellow} nos permite concatenar [**variables de DISTINTO tipo y MISMA longitud**]{.hl-yellow} --\> usaremos [**tibble**]{.hl-yellow} como una opci√≥n mejorada de base de datos

---


## üê£ Caso pr√°ctico {#caso-pr√°ctico-3a}

Del paquete `Biostatistics` usaremos el conunto de datos `pinniped`

```{r}
#| eval: false
Biostatistics::pinniped
```


1. ¬øQu√© [**representan**]{.hl-yellow} los datos? ¬øQu√© [**tipo de dato**]{.hl-yellow} es? En caso de que no lo sea, convierte la base de datos a un `tibble` (renombra con `pinniped_tb`)

```{r}
#| code-fold: true
#| eval: false
? Biostatistics::pinniped
```

```{r}
#| code-fold: true
class(Biostatistics::pinniped) # no es un tibble
pinniped_tb <- as_tibble(Biostatistics::pinniped)
```

. . .

2. ¬øCu√°ntos registros hay? ¬øY variables? ¬øDe qu√© tipo es cada una?


```{r}
#| code-fold: true
nrow(pinniped_tb)
ncol(pinniped_tb)
```


---

## üê£ Caso pr√°ctico {#caso-pr√°ctico-3a-2}


3. Incorpora una [**variable extra llamada phoca**]{.hl-yellow} que sea de tipo l√≥gico y que nos diga si una especie es de la categor√≠a `Phoca` o no.

```{r}
#| code-fold: true
pinniped_tb$phoca <- pinniped_tb$Species == "Phoca"
```

. . .

4. ¬øA qu√© sexo le [**pesa m√°s el cerebro**]{.hl-yellow}: a las hembras o a los machos? ¬øA quienes les [**pesa m√°s el cuerpo**]{.hl-yellow}: a los mon√≥gamos o a los pol√≠gamos?

```{r}
#| code-fold: true
# ¬øa qui√©n le pesa m√°s el cerebro?
mean(pinniped_tb$Male_brain_g, na.rm = TRUE) >
  mean(pinniped_tb$Female_brain_g, na.rm = TRUE)

# ¬øa qui√©n le pesa m√°s el cerebro?
mean(c(pinniped_tb$Male_mass_Kg[pinniped_tb$Mate_type == "mono"],
       pinniped_tb$Female_mass_Kg[pinniped_tb$Mate_type == "mono"])) >
  mean(c(pinniped_tb$Male_mass_Kg[pinniped_tb$Mate_type == "poly"],
         pinniped_tb$Female_mass_Kg[pinniped_tb$Mate_type == "poly"]))
```

---

## üê£ Caso pr√°ctico {#caso-pr√°ctico-3a-3}


5. Incopora una nueva variable que represente la [**diferencia entre el peso del cerebro entre machos y hembras**]{.hl-yellow} (machos - hembras) para cada especie.

```{r}
#| code-fold: true
pinniped_tb$dif_m_f <- pinniped_tb$Male_brain_g - pinniped_tb$Female_brain_g
pinniped_tb
```



# Clase 4: comunicar {#clase-4}

[**Comunicar resultados: rmd y Quarto**]{style="color:#444442;"}

---

## Comunicar: rmd y Quarto

Una de las [**principales fortalezas**]{.hl-yellow} de `R` es la [**facilidad para generar informes, libros, webs, apuntes y hasta diapositivas**]{.hl-yellow} (este mismo material por ejemplo). Para ello [**instalaremos**]{.hl-purple} antes

::: columns
::: {.column width="40%"}
-   el paquete `{rmarkdown}` (para generar archivos `.rmd`)

```{r}
#| eval: false
install.packages("rmarkdown")
```

-   instalar [**Quarto**](https://quarto.org/docs/get-started/) (el ¬´nuevo¬ª `.rmd` ahora como `.qmd`)
:::

::: {.column width="60%"}
![](img/quarto.png)
:::
:::

---

## Comunicar: rmd y Quarto

Hasta ahora solo hemos programado en scripts (archivos `.R`) dentro de proyectos, pero en muchas ocasiones [**no trabajaremos solos**]{.hl-yellow} y necesitaremos [**comunicar los resultados**]{.hl-yellow} en diferentes formatos:

-   apuntes (para nosotros mismos)
-   diapositivas
-   web
-   informes

. . .
 
Para todo ello usaremos [**Quarto (nuevo rmarkdown)**]{.hl-yellow}


---

## Comunicar: rmd y Quarto

Los archivos de extensi√≥n `.qmd` (o `.rmd`) nos permitir√°n f√°cilmente combinar:

-   [**Markdown**]{.hl-yellow}: [**lenguaje tipado**]{.hl-purple} que nos permite crear contenido simple (tipo wordpress, con texto, **negritas**, _cursivas_, etc) con un dise√±o legible.

. . .

-   [**Matem√°ticas (latex)**]{.hl-yellow}: lenguaje para escribir notaci√≥n matem√°tica como $x^2$ o $\sqrt{y}$ o $\int_{a}^{b} f(x) dx$

. . .

-   [**C√≥digo y salidas**]{.hl-yellow}: podremos no solo mostrar el paso final sino el c√≥digo que has ido realizando (no solo en `R`), con [**cajitas de c√≥digo llamadas chunks**]{.hl-purple}.

. . .

-   Im√°genes, [**gr√°ficas**]{.hl-yellow}, tablas, estilos (css, js), etc.

---

## Comunicar: rmd y Quarto

La principal ventaja de realizar este tipo de material en Quarto/Rmarkdown es que, al hacerlo desde `RStudio`, puedes generar un [**informe o una presentaci√≥n sin salirte del entorno de programaci√≥n**]{.hl-yellow} en el que est√°s trabajando

De esta forma podr√°s analizar los datos, resumirlos y a la vez comunicarlos con la misma herramienta.

. . .

Recientemente el equipo de `RStudio` desarroll√≥ [**Quarto**]{.hl-yellow}, una versi√≥n mejorada de Rmarkdown (archivos `.qmd`), con un formato un poco m√°s est√©tico y simple. Tienes toda la documentaci√≥n y ejemplos en [**https://quarto.org/**](https://quarto.org/)

---

## Nuestro primer informe

::: columns
::: {.column width="55%"}
![](img/quarto-create.png)
:::

::: {.column width="45%"}
Vamos a crear el [**primer fichero rmarkdown con Quarto**]{.hl-yellow} con extensi√≥n `.qmd`. Para ello solo necesitaremos hacer click en

`File << New File << Quarto Document`
:::
:::

---

## Nuestro primer informe

:::: columns
::: {.column width="45%"}
![](img/quarto-format.png)
:::

::: {.column width="55%"}
Tras hacerlo nos aparecer√°n varias [**opciones de formatos de salida**]{.hl-yellow}:

-   archivo `.pdf`
-   archivo `.html` ([**recomendable**]{.hl-yellow}): documento din√°mico, permite la interacci√≥n con el usuario, como una ¬´p√°gina web¬ª.
-   archivo `.doc` (nada recomendable)
:::
::::

. . .

De momento dejaremos marcado el [**formato HTML que viene por defecto**]{.hl-yellow}, y escribiremos el [**t√≠tulo**]{.hl-yellow} de nuestro documento. Tras ello tendremos nuestro [**archivo .qmd**]{.hl-yellow} (ya no es un script .R como los que hemos abierto hasta ahora).

---

## Nuestro primer informe

:::: columns
::: {.column width="60%"}
![](img/quarto-example.png)
:::

::: {.column width="40%"}

Deber√≠as tener algo similar a la captura de la imagen con [**dos modos de edici√≥n**]{.hl-yellow}: `Source` (con c√≥digo, la opci√≥n recomendada hasta que lo domines) y `Visual` (m√°s parecido a un blog)

:::
::::

Para [**ejecutar TODO el documento**]{.hl-yellow} debes clickar `Render on Save` y darle a guardar.

## Cabecera de un qmd

![](img/quarto-prueba-html.png)

Deber√≠as haber obtenido una [**salida en html similar a esta**]{.hl-yellow} (y se te ha generado en tu ordenador un [**archivo html**]{.hl-yellow})

---

## Nuestro primer informe

:::: columns
::: {.column width="50%"}
![](img/quarto-example.png)

:::

::: {.column width="50%"}

Un fichero `.qmd` se [**divide b√°sicamente en tres partes**]{.hl-yellow}:

* [**Cabecera**]{.hl-yellow}: la parte que tienes al inicio entre `---`.

* [**Texto**]{.hl-yellow}: que podremos formatear y mejorar con negritas (escrito como **negritas**, con doble ast√©risco al inicio y final), cursivas (_cursivas_, con barra baja al inicio y final) o destacar nombres de funciones o variables de R. Puedes a√±adir ecuaciones como $x^2$ (he escrito `$x^2$`, entre d√≥lares).

* [**C√≥digo R**]{.hl-yellow}

:::
::::

---

## Cabecera de un qmd

La [**cabecera est√°n en formato YAML**]{.hl-yellow} y contiene los [**metadatos**]{.hl-yellow} del documento:

:::: columns
::: {.column width="30%"}
![](img/quarto-cabecera.png)
:::

::: {.column width="70%"}

* `title` y `subtitle`: el t√≠tulo/subt√≠tulo del documento
* `author`: autor del mismo
* `date`: fecha
* `format`: formato de salida (podremos personalizar)
  * `theme`: si tienes alg√∫n archivo de estilos
  * `toc`: si quieres √≠ndice o no
  * `toc-location`: posici√≥n del √≠ndice
  * `toc-title`: t√≠tulo del √≠ndice
  * `toc-depth`: profundidad del √≠ndice
* `editor`: si est√°s en modo visual o source.

:::
::::

---

## Texto de un qmd

Respecto a la escritura solo hay una [**cosa importante**]{.hl-yellow}: salvo que indiquemos lo contrario, [**TODO lo que vamos a escribir es texto (normal)**]{.hl-yellow}. No c√≥digo R.

:::: columns
::: {.column width="35%"}
![](img/quarto-prueba-qmd2.png){width=350}
![](img/quarto-prueba-html2.png){width=320}
:::

::: {.column width="65%"}
Vamos a empezar escribiendo una secci√≥n al inicio (`# Intro` y detr√°s por ej. la frase

> Este material ha sido dise√±ado por el profesor Javier √Ålvarez Li√©bana, docente en la Universidad Complutense de Madrid

Adem√°s al `Running Code` le a√±adiremos una almohadilla `#`: las [**almohadillas FUERA DE CHUNKS**]{.hl-yellow} nos servir√°n para crear [**ep√≠grafes (secciones)**]{.hl-yellow} en el documento


:::
::::


---

## √çndice de un qmd

:::: columns
::: {.column width="40%"}
![](img/quarto-indice-qmd-2.png){width=370}
![](img/quarto-indice-html2.png){width=370}
:::

::: {.column width="60%"}
Para que el [**√≠ndice capture dichas secciones**]{.hl-yellow} modificaremos la cabecera del archivo como se observa en la imagen (puedes cambiar la localizaci√≥n del √≠ndice y el t√≠tulo si quieres para probar).

:::
::::

---

## Texto en un qmd

Vamos a [**personalizar un poco el texto**]{.hl-yellow} haciendo lo siguiente:


:::: columns
::: {.column width="50%"}
![](img/quarto-texto-mejorado-qmd.png){width=370}
![](img/quarto-texto-mejorado-html.png){width=370}
:::

::: {.column width="50%"}
* Vamos a a√±adir [**negrita al nombre**]{.hl-yellow} (poniendo ** al inicio y al final).

* Vamos a√±adir [**cursiva**]{.hl-yellow} a la palabra material (poniendo _ al inicio y al final).

* Vamos a√±adir un [**enlace**]{.hl-yellow} <https://www.ucm.es>, asoci√°ndolo al nombre de la Universidad. Para ello el t√≠tulo lo ponemos entre corchetes y justo detr√°s el enlace entre par√©ntesis `[¬´Universidad Complutense de Madrid¬ª](https://www.ucm.es)`

:::
::::

---

## C√≥digo en un qmd

Para [**a√±adir c√≥digo R**]{.hl-yellow} debemos crear nuestras [**cajas de c√≥digo llamadas chunks**]{.hl-yellow}: altos en el camino en nuestro texto markdown donde podremos incluir c√≥digo de casi cualquier lenguaje (y sus salidas).

&nbsp;

:::: columns
::: {.column width="50%"}
![](img/quarto-chunk-qmd.png){width=470}
:::

::: {.column width="50%"}

Para incluir uno deber√° de ir [**encabezado**]{.hl-yellow} de la siguiente forma tienes un atajo `Command + Option + I` (Mac) o `Ctrl + Shift + I` (Windows)
:::

::::

---

## C√≥digo en un qmd

Dentro de dicha cajita (que tiene ahora otro color en el documento) [**escribiremos c√≥digo R**]{.hl-yellow} como lo ven√≠amos haciendo hasta ahora en los scripts.

:::: columns
::: {.column width="50%"}
![](img/quarto-chunk-1-qmd.png){width=410}
![](img/quarto-chunk-1-html.png){width=410}
:::

::: {.column width="50%"}

 Vamos por ejemplo a definir dos variables y su suma de la siguiente manera, escribiendo dicho c√≥digo en nuestro `.qmd` (dentro de ese chunk)

```{r}
# C√≥digo R
x <- 1
y <- 2
x + y
```

:::

::::


---

## Etiquetando chunks


:::: columns
::: {.column width="50%"}
![](img/quarto-tag-chunks-qmd.png){width=400}
![](img/quarto-tag-chunks-html.png){width=400}
:::

::: {.column width="50%"}
Los chunks pueden tener un [**nombre o etiqueta**]{.hl-yellow}, de forma que podamos referenciarlos de nuevo para no repetir c√≥digo.
:::
::::


---

## Ejecutando chunks

:::: columns
::: {.column width="40%"}
![](img/quarto-inline-qmd.png){width=400}
![](img/quarto-inline-html.png){width=380}
:::

::: {.column width="60%"}
En cada chunk aparecen [**dos botones**]{.hl-yellow}:

* bot√≥n de [**play**]{.hl-yellow}: activa la [**ejecuci√≥n y salida de ese chunk particular**]{.hl-yellow} (lo puedes visualizar dentro de tu propio `RStudio`)

* bot√≥n de [**rebobinar**]{.hl-yellow}: activa la [**ejecuci√≥n y salida de todos los chunk hasta ese**]{.hl-yellow} (sin llegar a √©l)

&nbsp;

Adem√°s podemos [**incluir c√≥digo R dentro de la l√≠nea de texto**]{.hl-yellow} (en lugar de mostrar el texto x ejecuta el c√≥digo R mostrando la variable).
:::
::::



---

## Personalizaci√≥n de chunks

Los [**chunks podemos personalizarlos**]{.hl-yellow} con opciones al inicio del chunk precedido de `#|`:

* `#| echo: false`: [**ejecuta c√≥digo**]{.hl-green} y se [**muestra resultado**]{.hl-green} pero [**no visualiza c√≥digo**]{.hl-red} en la salida.

* `#| include: false`: [**ejecuta c√≥digo**]{.hl-green} pero [**no muestra resultado**]{.hl-red} y [**no visualiza c√≥digo**]{.hl-red} en la salida.

* `#| eval: false`: [**no ejecuta c√≥digo**]{.hl-red}, [**no muestra resultado**]{.hl-red} pero [**s√≠ visualiza c√≥digo**]{.hl-green} en la salida.

* `#| message: false`: [**ejecuta c√≥digo**]{.hl-green} pero [**no muestra mensajes de salida**]{.hl-red}.

* `#| warning: false`: [**ejecuta c√≥digo**]{.hl-green} pero [**no muestra mensajes de warning**]{.hl-red}.

* `#| error: true`: [**ejecuta c√≥digo**]{.hl-green} y [**permite que haya errores**]{.hl-green} mostrando el mensaje de error en la salida.


![](img/quarto-options-chunk.png){width=380}

Estas opciones podemos aplicarlas chunk a chunk o fijar los par√°metros de forma global con `knitr::opts_chunk$set()` al inicio del documento (dentro de un chunk).

---

## Organizando qmd

Adem√°s de texto y c√≥digo podemos introducir lo siguiente:

* [**Ecuaciones**]{.hl-yellow}: puedes a√±adir adem√°s ecuaciones como $x^2$ (he escrito `$x^2$`, la ecuaci√≥n entre d√≥lares).

* [**Listas**]{.hl-yellow}: puedes itemizar elementos poniendo `*`

`* Paso 1: ...`

`* Paso 2: ...`

* [**Cross-references**]{.hl-yellow}: puedes etiquetar partes del documento (la etiqueta se construye con `{#nombre-seccion}`) y llamarlas luego con `[Secci√≥n](@nombre-seccion)`

---

## Gr√°ficas/im√°genes en qmd

:::: columns
::: {.column width="50%"}
![](img/quarto-fig-qmd.png){width=340}
![](img/quarto-fig-html.png){width=390}
:::

::: {.column width="50%"}
Por √∫ltimo, tambi√©n podemos [**a√±adir pies de gr√°ficas o im√°genes**]{.hl-yellow} a√±adiendo `#| fig-cap: "..."`
:::
::::

. . .

:::: columns
::: {.column width="65%"}
F√≠jate que el [**caption est√° en el margen**]{.hl-yellow} (por ejemplo). Puedes cambiarlo introduciendo [**ajustes en la cabecera**]{.hl-yellow} (todo lo relativo a figuras empieza por `fig-`, y puedes ver las opciones tabulando). Tienes m√°s informaci√≥n en **<https://quarto.org/>**
:::

::: {.column width="35%"}
![](img/quarto-cabecera-desplegable.png){width=400}
:::
::::

---

## A√±adir estilos

:::: columns
::: {.column width="50%"}
![](img/quarto-estilos-qmd.png){width=400}
![](img/quarto-estilos-html.png){width=400}
:::

::: {.column width="50%"}
Por √∫ltimo puedes a√±adir un [**tema personalizado**]{.hl-yellow} incluyendo un [**archivo de estilos**]{.hl-yellow} (archivo en formato `.scss` o `.css`). Te he dejado uno en <https://github.com/dadosdelaplace/docencia-R-master-bio-2324/tree/main/material>.

::: callout-important
## Importante

El archivo de estilos debe estar en la misma carpeta que el archivo `.qmd`
:::
:::
::::

---

## üê£ Caso pr√°ctico {#caso-pr√°ctico-3a}

Elabora informes `.qmd` tal que


* Crea un archivo por cada uno de los [**casos pr√°cticos de los anteriores temas**]{.hl-yellow}, uno por tema

. . .

* En cada uno de ellos haz [**una secci√≥n por ejercicio**]{.hl-yellow}

. . .

* [**Detalla todos los pasos**]{.hl-yellow} que consideres mezclando texto, c√≥digo y salidas

. . .

* Si aparecen medidas estad√≠sticas como la media, [**prueba a meter f√≥rmulas**]{.hl-yellow} con `$$` (busca informaci√≥n de c√≥mo introducir ecuaciones en latex)

. . .

* Para avanzados: investiga las opciones del paquete `{DT}` (con la funci√≥n `datatable()`) que nos permite [**introducir dentro de los `.qmd` los datos en formato de tabla din√°mica**]{.hl-yellow}, permitiendo ordenar y filtrar.



# Clase 5: entrega I {#entrega-i}

[**Primera entrega individual en clase**]{style="color:#444442;"}

---

## Entrega I (26/09/2023)

Se actualizar√° al inicio de la clase correspondiente.

::: callout-important

## Importante

Esta [**entrega ponderar√° un 5% en la nota final**]{.hl-green}

Podr√°s [**usar todo el material del curso e internet**]{.hl-yellow} salvo cualquier aplicaci√≥n de mensajer√≠a o sistema de comunicaci√≥n: en caso de tener alguna abierta a lo largo de la entrega, aunque no se est√© usando, deber√°s [**abandonar la entrega y contar√° como un 0**]{.hl-red}.

Contar√°s con aproximadamente 90 minutos, pero [**deber√°s realizar la entrega**]{.hl-yellow}, como tarde, a las [**14:40**]{.hl-yellow}. Ser√° [**obligatorio subir tanto el `.qmd` como el `.html`**]{.hl-yellow}: una entrega que no haya podido ser renderizada (es decir, con errores graves) ser√° [**penalizada contando solo un 65% de la nota obtenida**]{.hl-red} (si la entrega es perfecta, la nota m√°xima ser√° un 6.5 sino se adjunta el `.html` generado).

Te recomiendo practicar bastante y preguntar dudas en clase y/o tutor√≠a ya que [**ir√°s justo de tiempo**]{.hl-yellow}, as√≠ que necesitas fluidez en los ejercicios.

Si usas un [**pc de la biblioteca**]{.hl-yellow} aseg√∫rate de tomarlo con suficiente antelaci√≥n para [**instalar todas las librer√≠as necesarias antes de empezar**]{.hl-yellow} para no perder tiempo.

:::


# Clase 6: tidydata {#clase-6}

[**Nuestra base de datos: tibble. Tidydata: un multiverso de datos limpios**]{style="color:#444442;"}

---

## Previously, in Breaking Bad...

Nuestro [**formato final de base de datos**]{.hl-yellow} ser√° el objeto de tipo `tibble`, un `data.frame` mejorado

```{r}
library(tibble)
tibble("estatura" = c(1.7, 1.8, 1.6), "peso" = c(80, 75, 70), "IMC" = peso / (estatura^2))
```

-   [**Metainformaci√≥n**]{.hl-yellow}: en la cabecera nos dice ya autom√°ticamente el n√∫mero de filas y columnas, y el tipo de cada variable

. . .

-   [**Recursividad**]{.hl-yellow}: permite definir las variables secuencialmente (como hemos visto)

. . .

-   [**Consistencia**]{.hl-yellow}: si accedes a una columna que no existe avisa con un warning

. . .

-   [**Por filas**]{.hl-yellow}: permite crear por filas con `tribble()`

---

## Previously, in Breaking Bad...

Para definir un `tibble()` nosotro mismos tenemos dos opciones:

* [**Concatenando vectores**]{.hl-yellow} que ya tengamos definidos, haciendo uso de la funci√≥n `tibble()` del paquete `{tibble}` (ya incluido en `{tidyverse}`)

```{r}
estatura <- c(1.7, 1.8, 1.6)
peso <- c(80, 75, 70)
IMC <-  peso / (estatura^2)
tibble("estatura" = estatura, "peso" = peso,
       "IMC" = IMC)
```

---

## Previously, in Breaking Bad...

* [**Directamente en tibble**]{.hl-yellow} proporcionando manualmente valores y nombres de variables

```{r}
tibble("estatura" = c(1.7, 1.8, 1.6),
       "peso" = c(80, 75, 70),
       "IMC" = peso / (estatura^2))
```

---


## R base vs Tidyverse

Si conoces alg√∫n otro lenguaje de programaci√≥n (o tienes gente cercana que programa) te extra√±ar√° que a√∫n no hayamos hablado de conceptos habituales como

-   [**Bucles for**]{.hl-yellow}: repetir un c√≥digo un n√∫mero fijo de iteraciones.

-   [**Bucles while**]{.hl-yellow}: repetir un c√≥digo hasta que se cumpla una condici√≥n

-   [**Estructuras if-else**]{.hl-yellow}: estructuras de control para decidir por donde camina el c√≥digo en funci√≥n del valor de las variables.

. . .

Y aunque conocer dichas estructuras puede sernos en alg√∫n momento interesante, en la [**mayor√≠a de ocasiones vamos a poder evitarlas**]{.hl-red} (en especial los bucles)

---

## ¬øQu√© es tidyverse?

::: columns
::: {.column width="50%"}
![](img/tidyverrse_universe.jpg)
:::

::: {.column width="50%"}
![](img/flow_tidyverse.jpg)
:::
:::

`{tidyverse}` es un [**¬´universo¬ª de paquetes**]{.hl-yellow} para garanatizar un flujo de trabajo (de inicio a fin) eficiente, coherente y lexicogr√°ficamente sencillo de entender, basado en la idea de que [**nuestros datos est√°n limpios y ordenados (tidy)**]{.hl-purple}

---

## ¬øQu√© es tidyverse?

::: columns
::: {.column width="45%"}
![](img/tidyverrse_universe.jpg)
:::

::: {.column width="55%"}
-   `{tibble}`: optimizando data.frame
-   `{tidyr}`: limpieza de datos
-   `{readr}`: carga datos rectangulares (.csv)
-   `{dplyr}`: gram√°tica para depurar
-   `{stringr}`: manejo de textos
-   `{ggplot2}`: visualizaci√≥n de datos
-   `{tidymodels}`: modelizaci√≥n/predicci√≥n
:::
:::

Tambi√©n tenemos los paquetes `{purrr}` para el manejo de listas, `{forcast}` para cualitativas, `{lubridate}` para fechas, `{readxl}` para importar archivos .xls y .xlsx, `{rvest}` para web scraping y `{rmarkdown}` para comunicar resultados.

---

## ¬øQu√© es tidyverse?

::: columns
::: {.column width="45%"}
![](img/tidyverrse_universe.jpg)
:::

::: {.column width="55%"}
-   `{tibble}`: [**optimizando data.frame**]{.hl-yellow}
-   `{tidyr}`: [**limpieza de datos**]{.hl-yellow}
-   `{readr}`: carga datos rectangulares (.csv)
-   `{dplyr}`: gram√°tica para depurar
-   `{stringr}`: manejo de textos
-   `{ggplot2}`: visualizaci√≥n de datos
-   `{tidymodels}`: modelizaci√≥n/predicci√≥n
:::
:::

Tambi√©n tenemos los paquetes `{purrr}` para el manejo de listas, `{forcast}` para cualitativas, `{lubridate}` para fechas, `{readxl}` para importar archivos .xls y .xlsx, `{rvest}` para web scraping y `{rmarkdown}` para comunicar resultados.

---

## Filosof√≠a base: tidy data

> Tidy datasets are all alike, but every messy dataset is messy in its own way (Hadley Wickham, Chief Scientist en RStudio)

::: {style="font-size:120px; text-align: center; color:#F8DF58;"}
<b>TIDY</b><b>[VERSE</b>]{style="color:#CAB0EE;"}
:::

El [**universo**]{.hl-purple} de paquetes `{tidyverse}` se basa en la idea introducido por **Hadley Wickham** (el Dios al que rezo) de [**estandarizar**]{.hl-yellow} el formato los datos para

::: incremental
-   [**sistematizar**]{.hl-green} la depuraci√≥n
-   hacer m√°s [**sencillo**]{.hl-green} su manipulaci√≥n.
-   c√≥digo [**legible**]{.hl-green}
:::

---

## Reglas del tidy data

Lo primero por tanto ser√° entender qu√© son los [**conjuntos tidydata**]{.hl-yellow} ya que todo `{tidyverse}` se basa en que los datos est√°n estandarizados.

::: columns
::: {.column width="50%"}
::: {.fragment .fade-in}
1.  Cada [**variable**]{.hl-yellow} en una [**√∫nica columna**]{.hl-purple}
:::

::: {.fragment .fade-in}
2.  Cada [**individuo**]{.hl-yellow} en una [**fila diferente**]{.hl-purple}
:::

::: {.fragment .fade-in}
3.  Cada [**celda**]{.hl-yellow} con un [**√∫nico valor**]{.hl-purple}
:::

::: {.fragment .fade-in}
4.  Cada [**dataset**]{.hl-yellow} en un [**tibble**]{.hl-purple}
:::

::: {.fragment .fade-in}
5.  Si queremos cruzar [**m√∫ltiples tablas**]{.hl-yellow} debemos tener una [**columna com√∫n**]{.hl-purple}
:::
:::

::: {.column width="50%"}
![](img/tidy_def.jpg){width="160%"}
:::
:::

---

## Tuber√≠a (pipe)

En `{tidyverse}` ser√° clave el [**operador pipe (tuber√≠a)**]{.hl-yellow} definido como `|>` ([**ctrl+shift+M**]{.hl-purple}): ser√° una [**tuber√≠a que recorre los datos**]{.hl-yellow} y los transforma.

. . .

::: columns
::: {.column width="50%"}
En R base, si queremos aplicar tres funciones `first()`, `second()` y `third()` en orden, ser√≠a

```{r}
#| eval: false
third(second(first(datos)))
```
:::

::: {.column width="50%"}
En `{tidyverse}` podremos [**leer de izquierda a derecha**]{.hl-yellow} y separar los datos de las acciones

```{r}
#| eval: false
datos |> first() |> second() |> third()
```
:::
:::

¬†

. . .

::: callout-caution
## Apunte importante

Desde la versi√≥n 4.1.0 de `R` disponemos de `|>`, un pipe **nativo** disponible [**fuera de tidyverse**]{.hl-purple}, sustituyendo al [**antiguo pipe**]{.hl-red} `%>%` que depend√≠a del paquete `{magrittr}` (bastante problem√°tico).
:::

---

## Tuber√≠a (pipe)

La principal ventaja es que el [**c√≥digo sea muy legible (casi literal)**]{.hl-yellow} pudiendo hacer grandes operaciones con los datos con apenas c√≥digo.

¬†

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  limpio(...) |>
  filtro(...) |>
  selecciono(...) |>
  ordeno(...) |>
  modifico(...) |>
  renombro(...) |>
  agrupo(...) |>
  cuento(...) |>
  resumo(...) |>
  pinto(...)
```
:::

::: {.column width="50%"}
<center><img src="img/logo_pipe.png" width="360px"/></center>
:::
:::

---

## Datos SUCIOS: messy data

¬øPero qu√© aspecto tienen los [**datos no tidy**]{.hl-yellow}? Vamos a cargar la tabla `table4a` del paquete `{tidyr}` (ya lo tenemos cargado del entorno tidyverse).

¬†

```{r}
library(tidyr)
table4a
```

¬†

[**¬øQu√© puede estar fallando?**]{.hl-red}

---

## Pivotar: pivot_longer()

::: columns
::: {.column width="40%"}
```{r}
table4a
```
:::

::: {.column width="60%"}
‚ùé Cada [**fila representa dos observaciones**]{.hl-red} (1999 y 2000) ‚Üí las columnas `1999` y `2000` en realidad deber√≠an ser en s√≠ [**valores de una variable**]{.hl-yellow} y no nombres de columnas.
:::
:::

. . .

Incluiremos una [**nueva columna**]{.hl-yellow} que nos guarde el a√±o y otra que guarde el valor de la variable de inter√©s en cada uno de esos a√±os. Y lo haremos con la funci√≥n `pivot_longer()`: [**pivotaremos la tabla**]{.hl-yellow} a formato long:

```{r}
table4a |> 
  pivot_longer(cols = c("1999", "2000"), names_to = "year", values_to = "cases")
```

---

## Pivotar: pivot_longer()

::: columns
::: {.column width="50%"}
```{r}
table4a |> 
  pivot_longer(cols = c("1999", "2000"),
               names_to = "year",
               values_to = "cases")
```
:::

::: {.column width="50%"}
![](img/table4a.jpg)
:::
:::

¬†

-   `cols`: [**nombre de las variables a pivotar**]{.hl-yellow}
-   `names_to`: nombre de la nueva variable a la quemandamos la [**cabecera**]{.hl-yellow} de la tabla (los nombres).
-   `values_to`: nombre de la nueva variable a la que vamos a mandar los [**datos**]{.hl-yellow}.

---

## Datos SUCIOS: messy data

Veamos otro ejemplo con la tabla `table2`

¬†

```{r}
table2
```

¬†

[**¬øQu√© puede estar fallando?**]{.hl-red}

---

## Pivotar: pivot_wider()

::: columns
::: {.column width="60%"}
```{r}
#| echo: false
table2
```
:::

::: {.column width="40%"}
‚ùé Cada [**observaci√≥n est√° dividido en dos filas**]{.hl-red} ‚Üí los [**registros con el mismo a√±o deber√≠an ser el mismo**]{.hl-yellow}
:::
:::

. . .

Lo que haremos ser√° lo opuesto: con `pivot_wider()` [**ensancharemos la tabla**]{.hl-yellow}

```{r}
table2 |>  pivot_wider(names_from = type, values_from = count)
```

---

## Datos SUCIOS: messy data

Veamos otro ejemplo con la tabla `table3`


```{r}
table3
```


[**¬øQu√© puede estar fallando?**]{.hl-red}

---

## Separar: separate()

::: columns
::: {.column width="60%"}
```{r}
table3
```
:::

::: {.column width="40%"}
‚ùé Cada [**celda contiene varios valores**]{.hl-red}
:::
:::

. . .

Lo que haremos ser√° hacer uso de la funci√≥n `separate()` para mandar [**separar cada valor**]{.hl-yellow} a una columna diferente.

```{r}
table3 |> separate(rate, into = c("cases", "pop"))
```

---

## Separar: separate()

```{r}
table3 |> separate(rate, into = c("cases", "pop"))
```

F√≠jate que los datos, aunque los ha separado, [**los ha mantenido como texto**]{.hl-red} cuando en realidad deber√≠an ser variables num√©ricas. Para ello podemos a√±adir el argumento opcional `convert = TRUE`

. . .

```{r}
table3 |> separate(rate, into = c("cases", "pop"), convert = TRUE)
```

---

## Datos SUCIOS: messy data

Veamos el √∫ltimo ejemplo con la tabla `table5`


```{r}
table5
```


[**¬øQu√© puede estar fallando?**]{.hl-red}

---

## Unir unite()

::: columns
::: {.column width="50%"}
```{r}
table5
```
:::

::: {.column width="50%"}
‚ùé Tenemos [**mismos valores divididos en dos columnas**]{.hl-red}
:::
:::

. . .

Usaremos `unite()` para [**unir los valores**]{.hl-yellow} de siglo y a√±o en una misma columna

```{r}
table5 |> unite(col = year_completo, century, year, sep = "")
```

---

## üíª Tu turno {#tu-turno-6}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

üìù Echa un vistazo a la tabla `table4b` del paquete `{tidyr}`. ¬øEs tidydata? En caso negativo, ¬øqu√© falla? ¬øC√≥mo convertirla a tidy data en caso de que no lo sea ya?

```{r}
#| code-fold: true
#| eval: false
table4b |>
  pivot_longer(cols = "1999":"2000", names_to = "year",
               values_to = "cases")
```

### [**Ejercicio 2**]{.hl-yellow}

üìù Echa un vistazo a la tabla `relig_income` del paquete `{tidyr}`. ¬øEs tidydata? En caso negativo, ¬øqu√© falla? ¬øC√≥mo convertirla a tidy data en caso de que no lo sea ya?

```{r}
#| code-fold: true
#| eval: false
relig_income |>
  pivot_longer(cols = "<$10k":"Don't know/refused",
               names_to = "income",
               values_to = "people")
```

### [**Ejercicio 3**]{.hl-yellow}

üìù Echa un vistazo a la tabla `billboard` del paquete `{tidyr}`. ¬øEs tidydata? En caso negativo, ¬øqu√© falla? ¬øC√≥mo convertirla a tidy data en caso de que no lo sea ya?

```{r}
#| code-fold: true
#| eval: false
billboard |>
  pivot_longer(cols = "wk1":"wk76",
               names_to = "week",
               names_prefix = "wk",
               values_to = "position",
               values_drop_na = TRUE)
```

:::

---

## üê£ Caso pr√°ctico {#caso-pr√°ctico-6}

En el paquete `{tidyr}` contamos con el dataset `who` (dataset de la Organizaci√≥n Mundial de la Salud)

```{r}
#| eval: false
library(tidyr)
who
```


1. ¬øQu√© [**significan los datos**]{.hl-yellow}? ¬øCu√°ntas [**variables y observaciones**]{.hl-yellow} tenemos?

. . .


2. ¬øCu√°ntos [**tipos de variables**]{.hl-yellow} tenemos?


. . .


3. ¬øTodas las variables son necesarias? [**Elimina la informaci√≥n redundante**]{.hl-yellow}.

. . .

4. [**Convierte a tidydata**]{.hl-yellow} la base de datos realizando todas las opciones que consideres (consejo: usa papel y boli para bocetar como deber√≠a quedar la base de datos).




# Clase 7: importar y exportar {#clase-7-importar}

[**Repasando tidydata. Importar/exportar datos en R**]{style="color:#444442;"}

---


## üê£ Caso pr√°ctico (anterior)

En el paquete `{tidyr}` contamos con el dataset `who` (dataset de la Organizaci√≥n Mundial de la Salud)

```{r}
#| eval: false
library(tidyr)
who
```


1. ¬øQu√© [**significan los datos**]{.hl-yellow}? ¬øCu√°ntas [**variables y observaciones**]{.hl-yellow} tenemos?

. . .


2. ¬øCu√°ntos [**tipos de variables**]{.hl-yellow} tenemos?


. . .


3. ¬øTodas las variables son necesarias? [**Elimina la informaci√≥n redundante**]{.hl-yellow}.

. . .

4. [**Convierte a tidydata**]{.hl-yellow} la base de datos realizando todas las opciones que consideres (consejo: usa papel y boli para bocetar como deber√≠a quedar la base de datos).


---

## Un poco m√°s de tidydata...

Del paquete `{tidyr}` usaremos el dataset `world_bank_pop`, que almacena la poblaci√≥n de cada pa√≠s y cada a√±o, seg√∫n el Banco Mundial. [**Convierte a tidydata**]{.hl-yellow}


```{r}
#| code-fold: true
world_bank_pop |> 
  pivot_longer(cols = "2000":"2017",
               names_to = "year",
               values_to = "pop",
               values_drop_na = TRUE)
```


---


## Importar/exportar datos

Hasta ahora solo hemos usado datos cargados ya en paquetes pero muchas veces [**necesitaremos importar datos de manera externa**]{.hl-yellow}. Una de las principales [**fortalezas**]{.hl-yellow} de `R` es que podemos importar datos de manera muy sencilla en distintos formatos:


* [**Formatos nativos de R**]{.hl-yellow}: formatos `.rda`, `.RData` y `.rds`

. . .

* [**Datos rectangulares (tabulados)**]{.hl-yellow}: formatos `.csv` y `.tsv`

. . .

* [**Datos sin tabular**]{.hl-yellow}: formato `.txt`

. . .

* [**Datos en excel**]{.hl-yellow}: formatos `.xls` y `.xlsx`

. . .

* [**Datos desde SAS/Stata/SPSS**]{.hl-yellow}: formatos `.sas7bdat`, `.sav` y `.dat`

. . .

* [**Datos desde API**]{.hl-yellow}: Google Drive, aemet, catastro, twitter, spotify, etc


---

## Formatos nativos de R

Los [**ficheros m√°s simples**]{.hl-yellow} para importar en `R` (y que suele ocupar menos espacio en disco) son sus propias [**extensiones nativas**]{.hl-yellow}: archivos con formatos `.RData`, `.rda` y `.rds`.

. . .

Para cargar los dos primeros simplemente necesitamos [**usar la funci√≥n nativa**]{.hl-yellow} `load()` indic√°ndole la ruta del archivo.

* Archivo `.RData`: vamos a importar un dataset con las distintas caracter√≠sticas de los [**viajeros del Titanic**]{.hl-purple}, incluyendo qui√©n sobrevivi√≥ y qui√©n muri√≥.


```{r}
#| eval: false
load("./datos/titanic.RData")
as_tibble(titanic)
```

```{r}
#| echo: false
library(tidyverse)
load("./datos/titanic.RData")
as_tibble(titanic) |> slice(1:5)
```


---

## Formatos nativos de R


* Archivo `.rda`: vamos a importar un dataset con [**datos de c√°ncer de pecho**]{.hl-purple} de [**Royston and Altman (2013)**](https://bmcmedresmethodol.biomedcentral.com/articles/10.1186/1471-2288-13-33), incluyendo 2982 pacientes y sus caracter√≠sticas


```{r}
#| eval: false
load("./datos/rotterdam_breast_cancer.rda")
as_tibble(rotterdam)
```

```{r}
#| echo: false
library(tidyverse)
load("./datos/rotterdam_breast_cancer.rda")
as_tibble(rotterdam) |> slice(1:7)
```


---

## Formatos nativos de R

* Archivo `.rds`: para este tipo debemos usar `readRDS()`, y necesitamos incorporar un [**argumento `file`**]{.hl-yellow} con la ruta. En este caso vamos a importar [**datos de c√°ncer de pulm√≥n**]{.hl-purple} del North Central Cancer Treatment Group.

```{r}
#| eval: false
lung_cancer <-
  readRDS(file = "./datos/NCCTG_lung_cancer.rds") |> as_tibble()
```

```{r}
#| echo: false
lung_cancer <-
  readRDS(survival::cancer, file = "./datos/NCCTG_lung_cancer.rds") |> 
  as_tibble()
lung_cancer |> slice(1:5)
```

::: callout-important

## Importante

Las [**rutas**]{.hl-yellow} deben ir siempre [**sin espacios, ni e√±es, ni tildes**]{.hl-yellow}. Y f√≠jate que los archivos cargados con `load()` se cargan autom√°ticamente en el environment (con el nombre guardado originalmente, sin necesidad de asignarlo a nada), pero las funciones `read()` solo se carga de manera local (sino se guarda, no existe a futuro)

:::

---

## Datos rectangulares: readr

El paquete `{readr}` dentro del entorno `{tidyverse}` contiene distintas funciones √∫tiles para la [**carga de datos rectangulares (sin formatear)**]{.hl-yellow}.

:::: columns
::: {.column width="50%"}

* `read_csv()`: archivos `.csv` cuyo [**separador sea la coma**]{.hl-purple}
* `read_csv2()`: [**punto y coma**]{.hl-purple}
* `read_tsv()`: [**tabulador**]{.hl-purple}.
* `read_table()`: [**espacio**]{.hl-purple}.
* `read_delim()`: funci√≥n gen√©rica para [**archivos delimitados por caracteres**]{.hl-purple}.


:::

::: {.column width="50%"}

![](img/data-import-readr.png)
:::
::::

Todos necesitan como **argumento la ruta del archivo** am√©n de **otros opcionales** (saltar o no cabecera, decimales, etc). Ver m√°s en <https://readr.tidyverse.org/>

---

## Datos tabulados (.csv, .tsv)

La principal ventaja de `{readr}` es que [**automatiza el formateo**]{.hl-yellow} para pasar de un archivo plano (sin formato) a un tibble (en filas y columnas, con formato).

. . .

* Archivo `.csv`: con `read_csv()` cargaremos archivos [**separados por coma**]{.hl-purple}, pasando como [**argumento la ruta**]{.hl-yellow} en `file = ...`. Vamos a importar el dataset `chickens.csv` (sobre pollos de dibujos animados, why not). Si te fijas en la salida nos proporciona el tipo de variables.

```{r}
library(readr)
chickens <- read_csv(file = "./datos/chickens.csv")
chickens
```

---

## Datos tabulados (.csv, .tsv)


El [**formato de las variables**]{.hl-yellow} normalmente lo har√° `read_csv()` de forma [**autom√°tica**]{.hl-yellow}, y podemos consultarlo con `spec()`

```{r}
spec(chickens)
```

---

## Datos tabulados (.csv, .tsv)

Aunque lo haga normalmente bien de forma autom√°tica podemos [**especificar el formato expl√≠citamente**]{.hl-yellow} en `col_types = list()` (en formato lista, con `col_xxx()` para cada tipo de variable, por ejemplo una la pondremos como cualitativa o factor). 


```{r}
chickens <-
  read_csv(file = "./datos/chickens.csv",
           col_types = list(col_character(), col_factor(), col_double(), col_character()))
chickens
```

---


## Datos tabulados (.csv, .tsv)

Incluso podemos indicar que [**variables que queremos seleccionar**]{.hl-yellow} (sin ocupar memoria), indic√°ndoselo en `col_select = ...`


```{r}
chickens <-
  read_csv(file = "./datos/chickens.csv",
           col_select = c(chicken, sex, eggs_laid))
chickens
```


---


## Datos sin tabular (.txt)


Vamos a usar de nuevo `read_csv()` con el archivo `massey-rating.txt`.

```{r}
datos_txt <- read_csv(file = "./datos/massey-rating.txt")
as_tibble(datos_txt)
```

. . .

Si te fijas nos interpreta todo como una sola columna: [**no tiene comas el archivo y no sabe por donde separar**]{.hl-yellow}

. . .


¬øQu√© sucede cuando el [**separador no es el correcto**]{.hl-red}?

---

## Datos sin tabular (.txt)

Para ello tenemos

* `read_csv2()` cuando el [**separador sea el punto y coma**]{.hl-yellow}, `read_tsv()` cuando el [**sea un tabulador**]{.hl-yellow} y `read_table()` cuando el [**sea un espacio**]{.hl-yellow}

* `read_delim()` en general

```{r}
datos_txt <- read_table(file = "./datos/massey-rating.txt")
as_tibble(datos_txt)
```


---

## Datos en excel (.xls, .xlsx)

Otro de los paquetes fundamentales de importaci√≥n ser√° el paquete  `{readxl}` para [**importar datos desde una Excel**]{.hl-yellow}. Tres funciones ser√°n claves:

* `read_xls()` espec√≠fica para `.xls`, `read_xlsx()` espec√≠fica para `.xlsx`
* `read_excel()`: para ambas

. . .

Vamos a importar `deaths.xlsx` con registros de fallecimientos de famosos

```{r}
#| eval: false
library(readxl)
deaths <- read_xlsx(path = "./datos/deaths.xlsx")
deaths
```

```{r}
#| echo: false
library(readxl)
deaths <- read_xlsx(path = "./datos/deaths.xlsx")
deaths |> slice(1:8)
```

---

## Datos en excel (.xls, .xlsx)


```{r}
#| eval: false
deaths
```

```{r}
#| echo: false
deaths |> slice(1:8)
```

Algo por [**desgracia muy habitual**]{.hl-yellow} es que haya [**alg√∫n tipo de comentario o texto al inicio**]{.hl-red} del archivo, teniendo que [**saltarnos dichas filas**]{.hl-yellow}.

---

## Datos en excel (.xls, .xlsx)

Podemos [**saltarnos dichas filas**]{.hl-yellow} directamente en la carga con `skip = ...` (indicando el n√∫mero de filas que nos saltamos)

```{r}
#| eval: false
library(readxl)
deaths <- read_xlsx(path = "./datos/deaths.xlsx", skip = 4)
deaths
```

```{r}
#| echo: false
library(readxl)
deaths <- read_xlsx(path = "./datos/deaths.xlsx", skip = 4)
deaths |> slice(1:5)
```

---

## Datos en excel (.xls, .xlsx)

Adem√°s con `col_names = ...` podemos renombrar ya las columnas en la importaci√≥n (si [**proporcionamos nombres asume la 1¬™ l√≠nea ya como un dato**]{.hl-yellow})

```{r}
#| eval: false
#| code-line-numbers: "3"
deaths <-
  read_xlsx(path = "./datos/deaths.xlsx",
            skip = 5,
            col_names = c("name", "profession", "age", "kids", "birth", "death"))
deaths
```

```{r}
#| echo: false
library(readxl)
deaths <- read_xlsx(path = "./datos/deaths.xlsx", skip = 5,
                    col_names = c("name", "profession", "age", "kids", "birth", "death"))
deaths |> slice(1:7)
```
        
---

## Datos en excel (.xls, .xlsx)


En ocasiones las [**fechas de Excel est√°n mal formateadas**]{.hl-red} (sorpresa): podemos hacer uso de `convertToDate()` del paquete `{openxlsx}` para convertirlo


```{r}
#| eval: false
library(openxlsx)
deaths$death <- convertToDate(deaths$death)
deaths
```
   
```{r}
#| echo: false
library(openxlsx)
deaths$death <- convertToDate(deaths$death)
deaths |> slice(1:7)
```

---

## Datos en excel (.xls, .xlsx)

Tambi√©n podemos [**cargar un Excel con varias hojas**]{.hl-yellow}: para [**indicarle la hoja**]{.hl-yellow} (bien por su nombre bien por su n√∫mero) usaremos el argumento `sheet = ...`

```{r}
#| eval: false
mtcars <- read_xlsx(path = "./datos/datasets.xlsx", sheet = "mtcars")
mtcars
```


```{r}
#| echo: false
mtcars <- read_xlsx(path = "./datos/datasets.xlsx", sheet = "mtcars")
mtcars |> slice(1:5)
```


. . .
 
Incluso podemos indicar el [**rango de celdas**]{.hl-yellow} a cargar con `range = ...`

```{r}
iris <- read_xlsx(path = "./datos/datasets.xlsx", sheet = "iris", range = "C1:E4")
iris
```



---

## Desde SAS/STATA/SPSS

El paquete `{haven}` dentro de la √≥rbita tidyverse nos permitir√° [**importar archivos de los 3 software de pago m√°s importantes**]{.hl-yellow}: SAS, SPSS y Stata

```{r}
library(haven)

# SAS
iris_sas <- read_sas(data_file = "./datos/iris.sas7bdat")

# SPSS
iris_spss <- read_sav(file = "./datos/iris.sav")

# Stata
iris_stata <- read_dta(file = "./datos/iris.dta")
```

---

## Exportar

De la misma manera que podemos importar tambi√©n podemos [**exportar**]{.hl-yellow}

* exportado en `.RData` (opci√≥n recomendada para variables guardadas en `R`). Recuerda que esta extensi√≥n [**solo se podr√° usar en `R`**]{.hl-yellow}. Para ello nos basta con usar `save(objeto, file = ruta)`

```{r}
tabla <- tibble("a" = 1:4, "b" = 1:4)
save(tabla, file = "./datos/tabla_prueba.RData")
rm(tabla) # eliminar
load("./datos/tabla_prueba.RData")
tabla
```

---


## Exportar

De la misma manera que podemos importar tambi√©n podemos [**exportar**]{.hl-yellow}

* exportado en `.RDS` (opci√≥n recomendada para variables guardadas en `R`). Recuerda que esta extensi√≥n [**solo se podr√° usar en `R`**]{.hl-yellow}. Para ello nos basta con usar `saveRDS(objeto, file = ruta)`

```{r}
saveRDS(tabla, file = "tabla.RDS") 
```

---

## Exportar

De la misma manera que podemos importar tambi√©n podemos [**exportar**]{.hl-yellow}

* exportado en `.csv`. Para ello nos basta con usar `write_csv(objeto, file = ruta)`

```{r}
write_csv(tabla, file = "./datos/tabla_prueba.csv")
read_csv(file = "./datos/tabla_prueba.csv")
```

---

## Exportar

De la misma manera que podemos importar tambi√©n podemos [**exportar**]{.hl-yellow}

* exportado en `.xlsx`. Para ello nos basta con usar `write.xlsx(objeto, file = ruta)` del paquete `{openxlsx}`

```{r}
library(openxlsx)
write.xlsx(tabla, file = "./datos/tabla_prueba.xlsx")
```

---

## Desde web

Una de las principales ventajas de `R` es que podemos hacer uso de todas las funciones anteriores de [**importar pero directamente desde una web**]{.hl-yellow}, sin necesidad de realizar la descarga manual: en lugar de pasarle la ruta local le indicaremos el [**enlace**]{.hl-yellow}. Por ejemplo, vamos a descargar los datos de covid del ISCIII (<https://cnecovid.isciii.es/covid19/#documentaci%C3%B3n-y-datos>)


```{r}
#| eval: false
covid_datos <-
  read_csv(file = "https://cnecovid.isciii.es/covid19/resources/casos_hosp_uci_def_sexo_edad_provres.csv")
covid_datos
```

```{r}
#| echo: false
covid_datos <-
  read_csv(file = "https://cnecovid.isciii.es/covid19/resources/casos_hosp_uci_def_sexo_edad_provres.csv", n_max = 700)
covid_datos
```

---

## Desde google drive

Otra opci√≥n disponible (sobre todo si trabajamos con otras personas que trabajan) es [**importar desde una hoja de c√°lculo Google Drive**]{.hl-yellow}, haciendo uso de `read_sheet()` del paquete `{googlesheets4}`

La primera vez te pedir√° un permiso de tidyverse para interactuar con vuestro drive

```{r}
#| eval: false
library(googlesheets4)
google_sheet <-
  read_sheet("https://docs.google.com/spreadsheets/d/1n_UTbD93-oDJR2r-rsMNff5ro147NL_ZN_vYIA2eJ3Q/edit?usp=sharing")
google_sheet
```

---

## Desde API (owid)

Una opci√≥n tambi√©n muy interesante es la [**carga de datos desde una API**]{.hl-yellow}: un intermediario entre una app o proveedor datos y nuestro `R`. Por ejemplo, vamos a cargar la librer√≠a `{owidR}`, que nos permite la descarga de datos de la web <https://ourworldindata.org/>. La funci√≥n `owid_covid()` nos carga sin darnos cuenta m√°s de 300 000 registros con m√°s de 50 variables de 238 pa√≠ses

```{r}
#| eval: false
library(owidR)
owid_covid()
```

```{r}
#| echo: false
#| eval: false
library(owidR)
owid_covid() |> slice(1:5)
```

---

## Desde API (owid)

Este paquete tiene la funci√≥n `owid_search()` para buscar datasets por palabras clave, por ejemplo, `emissions`, d√°ndonos un dataset con el t√≠tulo de la base de datos y su id para luego usarla.

```{r}
#| eval: false
as_tibble(owid_search("emissions"))
```

```{r}
#| echo: false
#| eval: false
as_tibble(owid_search("emissions")) |> slice(1:4)
```

. . .

Vamos a pedirle por ejemplo las [**emisiones de la oecd**]{.hl-yellow}

```{r}
#| eval: false
owid("emissions-of-air-pollutants-oecd")
```

```{r}
#| echo: false
#| eval: false
owid("emissions-of-air-pollutants-oecd") |> slice(1:5)
```

---

## Desde API (aemet)

En muchas ocasiones para conectar con la API tendremos antes que [**registrarnos y obtener una clave**]{.hl-yellow}, es el caso del paquete `{climaemet}` para acceder a datos meteorol√≥gicos (<https://opendata.aemet.es/centrodedescargas/inicio>)


Una vez que tenemos la clave de la API la registramos en nuestro RStudio para poder usarla a futuro


```{r}
library(climaemet)

# Definir la clave
apikey <- "eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJqYXZhbHYwOUB1Y20uZXMiLCJqdGkiOiI4YTU1ODUxMS01MTE3LTQ4MTYtYmM4OS1hYmVkNDhiODBkYzkiLCJpc3MiOiJBRU1FVCIsImlhdCI6MTY2NjQ2OTcxNSwidXNlcklkIjoiOGE1NTg1MTEtNTExNy00ODE2LWJjODktYWJlZDQ4YjgwZGM5Iiwicm9sZSI6IiJ9.HEMR77lZy2ASjmOxJa8ppx2J8Za1IViurMX3p1reVBU"

aemet_api_key(apikey, install = TRUE, overwrite = TRUE)
```

--- 

## Desde API (aemet)


Con dicho paquete podemos hacer una [**b√∫squeda de estaciones**]{.hl-yellow} para conocer tanto su c√≥digo postal como su c√≥digo identificador dentro de la red AEMET 

```{r}
stations <- aemet_stations()
stations
```

---

## Desde API (aemet)

Por ejemplo, la estaci√≥n del aeropuerto de El Prat, Barcelona, es el c√≥digo `"0076"`

```{r}
aemet_last_obs("0076")
```

---

## Desde API (catastro)

Tambi√©n puedes conectar con la [**API del catrastro**]{.hl-yellow} y buscar por ejemplo por coordenadas

```{r}
#| eval: false
library(CatastRo)
catr_ovc_get_rccoor(lat = 38.61965, lon = -3.45624, srs = "4230")
```

---

## Desde Spotify

Incluso podemos hacer un uso m√°s complejo de las API y bajarnos [**datos de sitios como Twitter o Spotify**]{.hl-yellow} (ver documentaci√≥n en <https://www.rcharlie.com/spotifyr/>)

```{r}
library(spotifyr)
Sys.setenv(SPOTIFY_CLIENT_ID = "79753b0500d34faaaef8673cc36bcf47")
Sys.setenv(SPOTIFY_CLIENT_SECRET = 'ca2955d430064ce5ba6a158a02a19772')
access_token <- get_spotify_access_token()
```

```{r}
rosalia <- get_artist_audio_features("Rosal√≠a")
as_tibble(rosalia)
```


---


## Desde chess.com

Incluso puedes bajarte [**datos de ajedrez**]{.hl-yellow} de plataformas como <https://chess.com> (y analizarlas)

```{r}
# devtools::install_github("JaseZiv/chessR")
library(chessR)
library(chess)
chess_data <- get_raw_chessdotcom(usernames = "DadosDeLaplace", year_month = c(202301:202303))
tibble::as_tibble(chess_data)
```

---


## üíª Tu turno {#tu-turno-7}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}


::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

üìù El dataset `who` que hemos usado en ejercicios anteriores, exp√≥rtalo a un formato nativo de `R` en la carpeta `datos` del proyecto

```{r}
#| code-fold: true
#| eval: false
library(tidyr)
save(who, file = "./datos/who.RData")
```

### [**Ejercicio 2**]{.hl-yellow}

üìù Carga el dataset `who` pero desde la carpeta de datos (importa el archivo creado en el ejercicio anterior)

```{r}
#| code-fold: true
#| eval: false
load("./datos/who.RData")
```

### [**Ejercicio 3**]{.hl-yellow}

üìù Repite lo mismo (exportar e importar) en 4 formatos: `.csv`, `.xlsx`, `.sav` (spss) y `.dta` (stata)

```{r}
#| code-fold: true
#| eval: false

# csv
library(readr)
write_csv(who, file = "./datos/who.csv")
who_data <- read_csv(file = "./datos/who.csv")

# excel
library(openxlsx)
write.xlsx(who, file = "./datos/who.xlsx")
who_data <- read_xlsx(path = "./datos/who.xlsx")

# sas y stata
library(haven)
write_sav(who, path = "./datos/who.sav")
who_data <- read_spss(path = "./datos/who.sav")

write_dta(who, path = "./datos/who.dta")
who_data <- read_dta(path = "./datos/who.dta")
```

### [**Ejercicio 4**]{.hl-yellow}

üìù Repite la carga del `who.csv` pero solo selecciona ya en la carga las 4 primeras columnas

```{r}
#| code-fold: true
#| eval: false
who_select <-
  read_csv(file = "./datos/who.csv",
           col_select = c("country", "iso2", "iso3", "year"))
```


:::

---

## üê£ Caso pr√°ctico {#caso-pr√°ctico-7}


En la carpeta de datos tienes el dataset `breast-cancer-wisconsin-data.csv`. Crea un archivo `.qmd` y personal√≠zalo incluyendo lo siguiente:

1. Importa el archivo csv a un `tibble`. ¬øEs tidydata? ¬øCu√°ntos pacientes y variables tenemos?

. . .

2. El dataset representa datos de c√°ncer de pecho (`id` identificador, `diagnosis` el diagn√≥stico maligno/benigno y el resto propiedades del tumor). Usando SOLO LO APRENDIDO, ¬øqu√© % ten√≠an un tumor maligno y qu√© % uno benigno?

. . .

3. ¬øCu√°l de los dos tipos de tumores tienen, de media, un radio m√°s elevado? 

. . .

4. Busca la ayuda de la funci√≥n `t.test()`. Dicha funci√≥n nos permite contrastar si la media de dos distribuciones son o no iguales. ¬øPodemos rechazar la hip√≥tesis nula de que la media del radio sea la misma, bajo una significancia de $\alpha = 0.05$?



# Clase 8: entrega II {#entrega-ii}

[**Segunda entrega individual en clase**]{style="color:#444442;"}

---

## Entrega II (06/10/2023)

Se actualizar√° al inicio de la clase correspondiente.

::: callout-important

## Importante

Esta [**entrega ponderar√° un 15% en la nota final**]{.hl-green}

Podr√°s [**usar todo el material del curso e internet**]{.hl-yellow} salvo cualquier aplicaci√≥n de mensajer√≠a o sistema de comunicaci√≥n: en caso de tener alguna abierta a lo largo de la entrega, aunque no se est√© usando, deber√°s [**abandonar la entrega y contar√° como un 0**]{.hl-red}.

Contar√°s con aproximadamente 110 minutos, pero [**deber√°s realizar la entrega**]{.hl-yellow}, como tarde, a las [**12:55**]{.hl-yellow}. Ser√° [**obligatorio subir tanto el `.qmd` como el `.html`**]{.hl-yellow}: una entrega que no haya podido ser renderizada (es decir, con errores graves) ser√° [**penalizada contando solo un 65% de la nota obtenida**]{.hl-red} (si la entrega es perfecta, la nota m√°xima ser√° un 6.5 sino se adjunta el `.html` generado).

Te recomiendo practicar bastante y preguntar dudas en clase y/o tutor√≠a ya que [**ir√°s justo de tiempo**]{.hl-yellow}, as√≠ que necesitas fluidez en los ejercicios.

Si usas un [**pc de la biblioteca**]{.hl-yellow} aseg√∫rate de tomarlo con suficiente antelaci√≥n para [**instalar todas las librer√≠as necesarias antes de empezar**]{.hl-yellow} para no perder tiempo.

:::


# Clase 9: tidyverse (filas) {#clase-9-tidyverse-filas}

[**Operaciones con filas**]{style="color:#444442;"}

---

## ...


# Clase 10: tidyverse (columnas) {#clase-10-tidyverse-columnas}

[**Operaciones con columnas**]{style="color:#444442;"}

---

## ...


# Clase 11: tidyverse (crear/modificar variables) {#clase-11-tidyverse-mutate}

[**Crear y/o modificar variables. Recodificar variables**]{style="color:#444442;"}

---

## ...


# Clase 12: funciones {#clase-12-funciones}

[**¬øQu√© es una funci√≥n? ¬øC√≥mo se definen? Variables locales vs globales. Uso con mutate.**]{style="color:#444442;"}

---

## ...


# Clase 13: res√∫menes y grupos {#clase-13-summary}

[**Summarise y group_by(). Contar y resumir: estad√≠sticas desagregadas por factores/grupos.**]{style="color:#444442;"}

---

## ...


# Clase 14: entrega III {#entrega-iii}

[**Segunda entrega individual en clase**]{style="color:#444442;"}

---

## Entrega III (27/10/2023)

Se actualizar√° al inicio de la clase correspondiente.

::: callout-important

## Importante

Esta [**entrega ponderar√° un 20% en la nota final**]{.hl-green}

Podr√°s [**usar todo el material del curso e internet**]{.hl-yellow} salvo cualquier aplicaci√≥n de mensajer√≠a o sistema de comunicaci√≥n: en caso de tener alguna abierta a lo largo de la entrega, aunque no se est√© usando, deber√°s [**abandonar la entrega y contar√° como un 0**]{.hl-red}.

Contar√°s con aproximadamente 110 minutos, pero [**deber√°s realizar la entrega**]{.hl-yellow}, como tarde, a las [**12:55**]{.hl-yellow}. Ser√° [**obligatorio subir tanto el `.qmd` como el `.html`**]{.hl-yellow}: una entrega que no haya podido ser renderizada (es decir, con errores graves) ser√° [**penalizada contando solo un 65% de la nota obtenida**]{.hl-red} (si la entrega es perfecta, la nota m√°xima ser√° un 6.5 sino se adjunta el `.html` generado).

Te recomiendo practicar bastante y preguntar dudas en clase y/o tutor√≠a ya que [**ir√°s justo de tiempo**]{.hl-yellow}, as√≠ que necesitas fluidez en los ejercicios.

Si usas un [**pc de la biblioteca**]{.hl-yellow} aseg√∫rate de tomarlo con suficiente antelaci√≥n para [**instalar todas las librer√≠as necesarias antes de empezar**]{.hl-yellow} para no perder tiempo.

:::


